
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Fractal Explorer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      body {
        overscroll-behavior: none;
      }
      /* Style for details/summary arrow */
      details[open] > summary .details-arrow {
        transform: rotate(180deg);
      }
      /* Simple modal styles */
      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.75);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 50;
      }
    </style>
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client"
      }
    }
    </script>
</head>
<body class="bg-gray-900 text-white font-sans">
    <div id="root"></div>
    <script type="module">
        import React, { useState, useEffect, useReducer, useCallback, useRef, forwardRef, useImperativeHandle } from 'react';
        import ReactDOM from 'react-dom/client';

        // --- Color Conversion Helpers ---
        const hexToRgb = (hex) => {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? [parseInt(result[1], 16) / 255, parseInt(result[2], 16) / 255, parseInt(result[3], 16) / 255] : [0, 0, 0];
        };
        const rgbToHex = (rgb) => "#" + rgb.map(c => Math.round(c * 255).toString(16).padStart(2, '0')).join('');

        // --- Fractal Service Logic ---
        const getWorkerScript = () => {
            return `
            const MAX_ZOOM_DEPTH_RATIO = 1e-15;

            function calculateFractalRow(jobData) {
                const { row, settings } = jobData;
                const { width, height, xmin, xmax, ymin, ymax, maxIterations, fractalType, cx, cy } = settings;

                const xminNum = parseFloat(xmin);
                const xmaxNum = parseFloat(xmax);
                const yminNum = parseFloat(ymin);
                const ymaxNum = parseFloat(ymax);

                const iterationCounts = new Int32Array(width);
                const dx = (xmaxNum - xminNum) / (width > 1 ? width - 1 : 1);
                const dy = (ymaxNum - yminNum) / (height > 1 ? height - 1 : 1);
                
                if (dx < MAX_ZOOM_DEPTH_RATIO || dy < MAX_ZOOM_DEPTH_RATIO) {
                  postMessage({
                      row: jobData.row,
                      jobId: jobData.jobId,
                      iterationCounts: new Int32Array(0),
                      error: 'Maximum zoom level reached for standard precision.'
                  });
                  return;
                }
                
                const cyNum = parseFloat(cy);
                const cxNum = parseFloat(cx);

                for (let i = 0; i < width; i++) {
                    let x0, y0, x, y;

                    if (fractalType === 'Julia') {
                        x0 = cxNum;
                        y0 = cyNum;
                        x = xminNum + i * dx;
                        y = ymaxNum - row * dy;
                    } else { // Mandelbrot
                        x0 = xminNum + i * dx;
                        y0 = ymaxNum - row * dy;
                        x = 0.0;
                        y = 0.0;
                    }

                    let iteration = 0;
                    
                    while (x * x + y * y <= 4 && iteration < maxIterations) {
                        let xtemp = x * x - y * y + x0;
                        y = 2 * x * y + y0;
                        x = xtemp;
                        iteration++;
                    }
                    
                    iterationCounts[i] = (iteration === maxIterations) ? -1 : iteration;
                }
                
                postMessage({
                    row: jobData.row,
                    jobId: jobData.jobId,
                    iterationCounts: iterationCounts
                });
            }

            self.onmessage = function(e) {
                calculateFractalRow(e.data);
            };
            `;
        };

        function hsbToRgb(h, s, v) {
            h = (h - Math.floor(h)) * 360;
            let r=0, g=0, b=0;
            const i = Math.floor(h / 60);
            const f = h / 60 - i;
            const p = v * (1 - s);
            const q = v * (1 - f * s);
            const t = v * (1 - (1 - f) * s);
            switch (i % 6) {
                case 0: r = v; g = t; b = p; break;
                case 1: r = q; g = v; b = p; break;
                case 2: r = p; g = v; b = t; break;
                case 3: r = p; g = q; b = v; break;
                case 4: r = t; g = p; b = v; break;
                case 5: r = v; g = p; b = q; break;
            }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        function interpolateColor(c1, c2, ratio) {
            return c1 + ratio * (c2 - c1);
        }

        function getPaletteColor(palette, position) {
            if (position < 0 || position > 1) position = position - Math.floor(position);

            let stopIndex = 1;
            while (stopIndex < palette.stops.length - 1 && position > palette.stops[stopIndex].pos) {
                stopIndex++;
            }

            const startStop = palette.stops[stopIndex - 1];
            const endStop = palette.stops[stopIndex];
            const ratio = (position - startStop.pos) / (endStop.pos - startStop.pos);
            
            const c1 = startStop.color;
            const c2 = endStop.color;
            
            const comp1 = interpolateColor(c1[0], c2[0], ratio);
            const comp2 = interpolateColor(c1[1], c2[1], ratio);
            const comp3 = interpolateColor(c1[2], c2[2], ratio);
            
            if (palette.colorType === 'HSB') {
                return hsbToRgb(comp1, comp2, comp3);
            }
            return [
                Math.round(Math.max(0, Math.min(255, comp1 * 255))),
                Math.round(Math.max(0, Math.min(255, comp2 * 255))),
                Math.round(Math.max(0, Math.min(255, comp3 * 255)))
            ];
        }

        function createPaletteColors(palette, length, offset) {
            const colors = new Array(length).fill([0, 0, 0]);
            if (length === 0) return colors;

            for (let i = 0; i < length; i++) {
                const position = i / (length > 1 ? length - 1 : 1);
                const colorIndex = (Math.round(i + offset * length)) % length;
                colors[colorIndex] = getPaletteColor(palette, position);
            }
            return colors;
        }

        const standardPalettes = {
            'Spectrum': { colorType: 'HSB', stops: [{ pos: 0, color: [0, 1, 1] }, { pos: 1, color: [1, 1, 1] }] },
            'Grayscale': { colorType: 'RGB', stops: [{ pos: 0, color: [0,0,0] }, { pos: 1, color: [1,1,1] }] },
            'CyclicGrayscale': { colorType: 'RGB', stops: [{ pos: 0, color: [0, 0, 0] }, { pos: 0.5, color: [1, 1, 1] }, { pos: 1, color: [0, 0, 0] }] },
            'Red/Cyan': { colorType: 'RGB', stops: [{ pos: 0, color: [1, 0, 0] }, { pos: 0.5, color: [0, 1, 1] }, { pos: 1, color: [1, 0, 0] }] },
            'Blue/Gold': { colorType: 'RGB', stops: [{ pos: 0, color: [0.1, 0.1, 1] }, { pos: 0.5, color: [1, 0.6, 0] }, { pos: 1, color: [0.3, 0.3, 1] }] },
            'EarthAndSky': { colorType: 'RGB', stops: [{ pos: 0, color: [1,1,1] },{ pos: 0.15, color: [1,0.8,0] },{ pos: 0.33, color: [0.53,0.12,0.075] },{ pos: 0.67, color: [0,0,0.6] },{ pos: 0.85, color: [0,0.4,1] },{ pos: 1, color: [1,1,1] }] },
            'HotAndCold': { colorType: "RGB", stops: [{ pos: 0, color: [1,1,1] },{ pos: 0.16, color: [0,0.4,1] },{ pos: 0.5, color: [0.2,0.2,0.2] },{ pos: 0.84, color: [1,0,0.8] },{ pos: 1, color: [1,1,1] }] },
            'Fire': { colorType: 'RGB', stops: [{ pos: 0, color: [0,0,0] },{ pos: 0.17, color: [1,0,0] },{ pos: 0.83, color: [1,1,0] },{ pos: 1, color: [1,1,1] }] },
            'Cyclic Fire': { colorType: 'RGB', stops: [{ pos: 0, color: [0,0,0] },{ pos: 0.2, color: [1,0,0] },{ pos: 0.4, color: [1,1,0] },{ pos: 0.5, color: [1,1,1] },{ pos: 0.6, color: [1,1,0] },{ pos: 0.8, color: [1,0,0] },{ pos: 1, color: [0,0,0] }] },
            'TreeColors': { colorType: "HSB", stops: [{ pos: 0, color: [0.1266,0.5955,0.2993] },{ pos: 0.33, color: [0.0896,0.3566,0.6575] },{ pos: 0.66, color: [0.6195,0.8215,0.4039] },{ pos: 1, color: [0.1266,0.5955,0.2993] }] },
            'Seashore': { colorType: 'RGB', stops: [{pos: 0, color: [0.7909,0.9961,0.7630]},{pos: 0.1667, color: [0.8974,0.8953,0.6565]},{pos: 0.3333, color: [0.9465,0.3161,0.1267]},{pos: 0.5, color: [0.5184,0.1109,0.0917]},{pos: 0.6667, color: [0.0198,0.4563,0.6839]},{pos: 0.8333, color: [0.5385,0.8259,0.8177]},{pos: 1, color: [0.7909,0.9961,0.7630]}] },
            'Pastels': { colorType: "RGB", stops: [{ pos: 0, color: [0.80585,0.81648,0.82180] },{ pos: 0.180781, color: [0.43882,0.52393,1] },{ pos: 0.418566, color: [1,0.35904,0.58244] },{ pos: 0.627035, color: [1,1,0.52127] },{ pos: 0.858306, color: [0.54787,0.93351,0.56914] },{ pos: 1, color: [0.80585,0.81648,0.82180] }] },
            'Dark': { colorType: "RGB", stops: [{ pos: 0, color: [0.65957,0,0] },{ pos: 0.18241, color: [0,0.30585,0.58776] },{ pos: 0.38599, color: [0.81648,0.41489,0.07180] },{ pos: 0.57166, color: [0,0.48670,0.16489] },{ pos: 0.78338, color: [0.29787,0.13829,0.75] },{ pos: 1, color: [0.65957,0,0] }] },
        };

        const defaultSettings = {
            fractalType: 'Mandelbrot',
            xmin: '-2.2', xmax: '0.8', ymin: '-1.2', ymax: '1.2',
            cx: '-0.8', cy: '0.156',
            width: 800, height: 600,
            maxIterations: 1000,
            palette: standardPalettes.Spectrum,
            paletteLength: 250, paletteOffset: 0,
            interlaced: true,
        };

        // --- Undoable Reducer Hook ---
        const useUndoableReducer = (reducer, initialPresent) => {
          const initialState = {
            past: [],
            present: initialPresent,
            future: [],
          };

          const [state, dispatch] = useReducer((state, action) => {
            const { past, present, future } = state;
            switch (action.type) {
              case 'UNDO':
                if (past.length === 0) return state;
                const previous = past[past.length - 1];
                return { past: past.slice(0, past.length - 1), present: previous, future: [present, ...future] };
              case 'REDO':
                if (future.length === 0) return state;
                const next = future[0];
                return { past: [...past, present], present: next, future: future.slice(1) };
              case 'SET':
                if (action.newPresent === present) return state;
                return { past: [...past, present], present: action.newPresent, future: [] };
              case 'RESET':
                return { past: [], present: action.newPresent, future: [] };
              default:
                const newPresent = reducer(present, action);
                if (present === newPresent) return state;
                return { past: [...past, present], present: newPresent, future: [] };
            }
          }, initialState);

          const canUndo = state.past.length > 0;
          const canRedo = state.future.length > 0;
          const memoizedDispatch = useCallback(dispatch, [dispatch]);

          return [state, memoizedDispatch, canUndo, canRedo];
        };

        // --- UI Components ---
        const UndoIcon = () => React.createElement("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, React.createElement("path", { d: "M3 7v6h6" }), React.createElement("path", { d: "M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13" }));
        const RedoIcon = () => React.createElement("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, React.createElement("path", { d: "M21 7v6h-6" }), React.createElement("path", { d: "M3 17a9 9 0 0 0 9-9 9 9 0 0 0 6 2.3l3 2.7" }));
        const SettingsIcon = () => React.createElement("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, React.createElement("path", { d: "M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 0 2.4l-.15.08a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.38a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1 0-2.4l.15.08a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z" }), React.createElement("circle", { cx: "12", cy: "12", r: "3" }));
        const SaveIcon = () => React.createElement("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, React.createElement("path", { d: "M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" }), React.createElement("polyline", { points: "17 21 17 13 7 13 7 21" }), React.createElement("polyline", { points: "7 3 7 8 15 8" }));
        const RandomIcon = () => React.createElement("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round"}, React.createElement("path", {d: "M3 7v6h6"}), React.createElement("path", {d: "M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"}), React.createElement("path", {d: "m21 16-4-4 4-4"}), React.createElement("path", {d: "m3 8 4 4-4 4"}));
        const SidebarToggleIcon = ({ isOpen }) => React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round", className: `transition-transform duration-300 ${isOpen ? '' : 'rotate-180'}` }, React.createElement("rect", { x: "3", y: "3", width: "18", height: "18", rx: "2", ry: "2" }), React.createElement("line", { x1: "9", y1: "3", x2: "9", y2: "21" }), React.createElement("polyline", { points: `14 9 17 12 14 15` }));

        const Button = ({ onClick, disabled, children, className, title }) => React.createElement("button", { onClick, disabled, title, className: `px-3 py-2 text-sm font-semibold rounded-md flex items-center justify-center gap-2 transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-800 focus:ring-cyan-400 ${disabled ? 'bg-gray-600 text-gray-400 cursor-not-allowed' : 'bg-gray-700 hover:bg-gray-600 text-white'} ${className}` }, children);
        const ControlGroup = ({ title, children }) => React.createElement("details", { open: true, className: "border-b border-gray-700" }, React.createElement("summary", { className: "py-3 px-4 text-sm font-bold uppercase tracking-wider text-gray-400 cursor-pointer hover:bg-gray-800 transition-colors list-none flex items-center justify-between" }, title, React.createElement("svg", { className: "w-4 h-4 text-gray-500 transition-transform duration-200 transform details-arrow", viewBox: "0 0 24 24" }, React.createElement("path", { d: "M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z", fill: "currentColor" }))), React.createElement("div", { className: "p-4 space-y-4" }, children));
        const LabelInput = ({ label, children }) => React.createElement("label", { className: "grid grid-cols-2 items-center gap-2 text-sm" }, React.createElement("span", { className: "text-gray-300" }, label), children);
        const Select = (props) => React.createElement("select", { ...props, className: `w-full bg-gray-800 border border-gray-600 rounded-md px-2 py-1.5 text-sm focus:outline-none focus:ring-1 focus:ring-cyan-400 focus:border-cyan-400 ${props.className}` });
        const Input = (props) => React.createElement("input", { ...props, className: `w-full bg-gray-800 border border-gray-600 rounded-md px-2 py-1.5 text-sm focus:outline-none focus:ring-1 focus:ring-cyan-400 focus:border-cyan-400 ${props.className}` });
        
        // --- Palette Editor Component ---
        const PaletteEditor = ({ palette: initialPalette, onSave, onCancel }) => {
            const [palette, setPalette] = useState(() => JSON.parse(JSON.stringify(initialPalette)));

            const handleStopChange = (index, key, value) => {
                const newStops = [...palette.stops];
                newStops[index] = { ...newStops[index], [key]: value };
                setPalette({ ...palette, stops: newStops });
            };

            const handleAddStop = () => {
                const currentStops = palette.stops;
                let maxGap = 0;
                let insertIndex = -1;
        
                for (let i = 0; i < currentStops.length - 1; i++) {
                    const gap = currentStops[i+1].pos - currentStops[i].pos;
                    if (gap > maxGap) {
                        maxGap = gap;
                        insertIndex = i;
                    }
                }
        
                if (insertIndex !== -1) {
                    const startStop = currentStops[insertIndex];
                    const endStop = currentStops[insertIndex + 1];
                    const newPos = startStop.pos + maxGap / 2;
                    const newColor = startStop.color.map((c, j) => (c + endStop.color[j]) / 2);
                    const newStops = [...currentStops, { pos: newPos, color: newColor }]
                        .sort((a, b) => a.pos - b.pos);
                    setPalette({ ...palette, stops: newStops });
                }
            };

            const handleRemoveStop = (index) => {
                if (palette.stops.length <= 2) return;
                const newStops = palette.stops.filter((_, i) => i !== index);
                setPalette({ ...palette, stops: newStops });
            };

            const handleSave = () => {
                const sortedPalette = { ...palette, stops: [...palette.stops].sort((a, b) => a.pos - b.pos) };
                onSave(sortedPalette);
            };
            
            const gradient = createPaletteColors(palette, 256, 0)
                .map(c => `rgb(${c[0]},${c[1]},${c[2]})`).join(',');

            return React.createElement("div", { className: "modal-overlay" },
                React.createElement("div", { className: "bg-gray-800 rounded-lg shadow-xl w-full max-w-2xl max-h-[90vh] flex flex-col" },
                    React.createElement("header", { className: "p-4 border-b border-gray-700" }, React.createElement("h2", { className: "text-lg font-bold" }, "Palette Editor")),
                    React.createElement("main", { className: "p-4 flex-1 overflow-y-auto" },
                        React.createElement("div", { className: "h-10 w-full rounded mb-4", style: { background: `linear-gradient(to right, ${gradient})` }}),
                        React.createElement("div", { className: "space-y-3" },
                            palette.stops.map((stop, i) => React.createElement("div", { key: i, className: "grid grid-cols-[auto,1fr,auto,auto] gap-3 items-center" },
                                React.createElement("span", { className: "text-sm font-mono w-12" }, `${(stop.pos * 100).toFixed(1)}%`),
                                React.createElement("input", { type: "range", min: "0", max: "1", step: "0.001", value: stop.pos, onChange: e => handleStopChange(i, 'pos', parseFloat(e.target.value)), disabled: i === 0 || i === palette.stops.length - 1 }),
                                React.createElement("input", { type: "color", value: rgbToHex(stop.color), onChange: e => handleStopChange(i, 'color', hexToRgb(e.target.value)), className: "bg-transparent w-10 h-8 p-0 border-0 cursor-pointer" }),
                                React.createElement("button", { onClick: () => handleRemoveStop(i), disabled: palette.stops.length <= 2, className: "text-red-400 disabled:text-gray-600" }, "Remove")
                            ))
                        )
                    ),
                    React.createElement("footer", { className: "p-4 border-t border-gray-700 flex justify-between" },
                        React.createElement(Button, { onClick: handleAddStop }, "Add Color Stop"),
                        React.createElement("div", { className: "space-x-2" },
                          React.createElement(Button, { onClick: onCancel, className: "bg-gray-600 hover:bg-gray-500" }, "Cancel"),
                          React.createElement(Button, { onClick: handleSave, className: "bg-cyan-600 hover:bg-cyan-500" }, "Save Changes")
                        )
                    )
                )
            );
        };
        
        // --- Fractal Canvas Component ---
        const FractalCanvas = forwardRef(({ state, dispatch, setUndoPoint }, ref) => {
          const { settings, workerCount, isComputing } = state;
          const canvasRef = useRef(null);
          const containerRef = useRef(null);
          const offscreenCanvasRef = useRef(null);
          const workersRef = useRef([]);
          const jobIdRef = useRef(0);
          const isPanningRef = useRef(false);
          const panStartRef = useRef({ x: 0, y: 0 });
          const [cursor, setCursor] = useState('grab');
          const debounceTimerRef = useRef(null);
          const [viewTransform, setViewTransform] = useState({ x: 0, y: 0, scale: 1 });

          useEffect(() => () => {
              workersRef.current.forEach(w => w.terminate());
              clearTimeout(debounceTimerRef.current);
            }, []);

          const stopComputation = useCallback(() => {
            jobIdRef.current++;
            workersRef.current.forEach(w => w.terminate());
            workersRef.current = [];
            dispatch({ type: 'SET_IS_COMPUTING', payload: false });
            dispatch({ type: 'SET_STATUS', payload: 'Computation stopped by user.' });
            dispatch({ type: 'SET_PROGRESS', payload: 0 });
          }, [dispatch]);
          
          const commitViewTransform = useCallback((transform) => {
                const { xmin, xmax, ymin, ymax, width, height } = settings;
                const [xminNum, xmaxNum, yminNum, ymaxNum] = [xmin, xmax, ymin, ymax].map(parseFloat);
                const xRange = xmaxNum - xminNum;
                const yRange = ymaxNum - yminNum;

                const newCenterPxX = (width / 2 - transform.x) / transform.scale;
                const newCenterPxY = (height / 2 - transform.y) / transform.scale;

                const newCenterX = xminNum + (newCenterPxX / width) * xRange;
                const newCenterY = ymaxNum - (newCenterPxY / height) * yRange;

                const newXRange = xRange / transform.scale;
                const newYRange = yRange / transform.scale;

                const newLimits = {
                    xmin: (newCenterX - newXRange / 2).toPrecision(16),
                    xmax: (newCenterX + newXRange / 2).toPrecision(16),
                    ymin: (newCenterY - newYRange / 2).toPrecision(16),
                    ymax: (newCenterY + newYRange / 2).toPrecision(16),
                };

                setUndoPoint(settings);
                dispatch({ type: 'SET_LIMITS', payload: newLimits });
                setViewTransform({ x: 0, y: 0, scale: 1 });
            }, [settings, dispatch, setUndoPoint]);

           const zoom = useCallback((zoomFactor) => {
            if (isComputing) return;

            const { width, height } = settings;
            const centerX = width / 2;
            const centerY = height / 2;

            const newScale = viewTransform.scale * (1 / zoomFactor);
            const newX = centerX + (viewTransform.x - centerX) * (1 / zoomFactor);
            const newY = centerY + (viewTransform.y - centerY) * (1 / zoomFactor);

            setViewTransform({ x: newX, y: newY, scale: newScale });

            clearTimeout(debounceTimerRef.current);
            debounceTimerRef.current = setTimeout(() => {
                commitViewTransform({ x: newX, y: newY, scale: newScale });
            }, 300);
        }, [isComputing, settings, viewTransform, commitViewTransform]);


          useImperativeHandle(ref, () => ({ stopComputation, zoom, getCanvas: () => canvasRef.current }), [stopComputation, zoom]);
          
          const startComputation = useCallback(() => {
            if (!canvasRef.current) return;
            jobIdRef.current++;
            const currentJobId = jobIdRef.current;
            dispatch({ type: 'SET_IS_COMPUTING', payload: true });
            dispatch({ type: 'SET_PROGRESS', payload: 0 });
            dispatch({ type: 'SET_STATUS', payload: 'Initializing computation...' });
            workersRef.current.forEach(w => w.terminate());
            const blob = new Blob([getWorkerScript()], { type: 'application/javascript' });
            const workerUrl = URL.createObjectURL(blob);
            workersRef.current = Array.from({ length: workerCount }, () => new Worker(workerUrl));
            if (!offscreenCanvasRef.current || offscreenCanvasRef.current.width !== settings.width || offscreenCanvasRef.current.height !== settings.height) {
                offscreenCanvasRef.current = new OffscreenCanvas(settings.width, settings.height);
            }
            const offscreenCtx = offscreenCanvasRef.current.getContext('2d');
            offscreenCtx.fillStyle = '#111827';
            offscreenCtx.fillRect(0, 0, settings.width, settings.height);
            
            let jobsCompleted = 0;
            const totalJobs = settings.height;
            const palette = createPaletteColors(settings.palette, settings.paletteLength || settings.maxIterations, settings.paletteOffset);

            const drawRow = (row, iterationCounts) => {
                const ctx = offscreenCanvasRef.current?.getContext('2d');
                if (!ctx) return;
                const imageData = ctx.createImageData(settings.width, 1);
                for (let i = 0; i < settings.width; i++) {
                    const iter = iterationCounts[i];
                    const color = iter === -1 ? [0, 0, 0] : palette[iter % palette.length] || [0,0,0];
                    const pxIndex = i * 4;
                    [imageData.data[pxIndex], imageData.data[pxIndex + 1], imageData.data[pxIndex + 2], imageData.data[pxIndex + 3]] = [...color, 255];
                }
                ctx.putImageData(imageData, 0, row);
                const mainCtx = canvasRef.current?.getContext('2d');
                if (mainCtx && offscreenCanvasRef.current) mainCtx.drawImage(offscreenCanvasRef.current, 0, 0);
            };
            
            workersRef.current.forEach(worker => {
              worker.onmessage = (e) => {
                if ('error' in e.data) {
                    dispatch({ type: 'SET_STATUS', payload: e.data.error });
                    dispatch({ type: 'SET_IS_COMPUTING', payload: false });
                    jobIdRef.current++; return;
                }
                const { row, jobId, iterationCounts } = e.data;
                if (jobId !== currentJobId) return;
                drawRow(row, iterationCounts);
                jobsCompleted++;
                const progress = jobsCompleted / totalJobs;
                dispatch({ type: 'SET_PROGRESS', payload: progress });
                dispatch({ type: 'SET_STATUS', payload: `Computing... ${(progress * 100).toFixed(0)}%` });
                if (jobsCompleted >= totalJobs) {
                  dispatch({ type: 'SET_IS_COMPUTING', payload: false });
                  dispatch({ type: 'SET_STATUS', payload: 'Render complete.' });
                  URL.revokeObjectURL(workerUrl);
                }
              };
            });

            const rows = Array.from({ length: settings.height }, (_, i) => i);
            if (settings.interlaced) rows.sort((a, b) => (a % 2) - (b % 2));
            let jobIndex = 0;
            workersRef.current.forEach(worker => {
                if (jobIndex < rows.length) worker.postMessage({ row: rows[jobIndex++], jobId: currentJobId, settings });
                worker.addEventListener('message', function onMessage() {
                    if (jobIndex < rows.length) worker.postMessage({ row: rows[jobIndex++], jobId: currentJobId, settings });
                    else worker.removeEventListener('message', onMessage);
                });
            });
          }, [settings, workerCount, dispatch]);

          useEffect(() => { startComputation(); }, [settings, workerCount, startComputation]);


          const handlePointerDown = (e) => {
            if (isComputing) return;
            e.preventDefault();

            if (e.shiftKey && settings.fractalType === 'Mandelbrot') {
                const rect = containerRef.current.getBoundingClientRect();
                const mouseXOnCanvas = e.clientX - rect.left;
                const mouseYOnCanvas = e.clientY - rect.top;

                const { xmin, xmax, ymin, ymax, width, height } = settings;
                const [xminNum, xmaxNum, yminNum, ymaxNum] = [xmin, xmax, ymin, ymax].map(parseFloat);
                
                const newCx = xminNum + (mouseXOnCanvas / width) * (xmaxNum - xminNum);
                const newCy = ymaxNum - (mouseYOnCanvas / height) * (ymaxNum - yminNum);

                setUndoPoint(settings);
                dispatch({ type: 'SET_JULIA_C', payload: { cx: newCx.toPrecision(16), cy: newCy.toPrecision(16) }});
                dispatch({ type: 'SET_FRACTAL_TYPE', payload: 'Julia' });
                return;
            }

            if (e.button === 0) { // Left mouse button
              clearTimeout(debounceTimerRef.current);
              isPanningRef.current = true;
              panStartRef.current = { x: e.clientX, y: e.clientY, transform: { ...viewTransform } };
              setCursor('grabbing');
            }
          };
          
          const handlePointerMove = (e) => {
            if (isPanningRef.current) {
              e.preventDefault();
              const dx = e.clientX - panStartRef.current.x;
              const dy = e.clientY - panStartRef.current.y;
              setViewTransform({
                  x: panStartRef.current.transform.x + dx,
                  y: panStartRef.current.transform.y + dy,
                  scale: panStartRef.current.transform.scale
              });
            }
          };

          const handlePointerUp = (e) => {
            if (!isPanningRef.current) return;
            isPanningRef.current = false;
            setCursor('grab');

            const dxPixels = e.clientX - panStartRef.current.x;
            const dyPixels = e.clientY - panStartRef.current.y;
            
            if (Math.abs(dxPixels) < 5 && Math.abs(dyPixels) < 5) {
                setViewTransform(panStartRef.current.transform);
                return;
            }
            
            commitViewTransform(viewTransform);
          };
          
          const handleWheel = useCallback((e) => {
            if (isComputing) return;
            e.preventDefault();
            
            const zoomFactor = e.deltaY < 0 ? 0.8 : 1.25;
            const rect = containerRef.current.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const newScale = viewTransform.scale / zoomFactor;
            const newX = mouseX + (viewTransform.x - mouseX) / zoomFactor;
            const newY = mouseY + (viewTransform.y - mouseY) / zoomFactor;

            setViewTransform({ x: newX, y: newY, scale: newScale });

            clearTimeout(debounceTimerRef.current);
            debounceTimerRef.current = setTimeout(() => {
                commitViewTransform({ x: newX, y: newY, scale: newScale });
            }, 300);

          }, [isComputing, settings, dispatch, setUndoPoint, viewTransform, commitViewTransform]);

          return React.createElement("div", {
              ref: containerRef, className: `relative w-full h-full touch-none overflow-hidden`,
              style: { cursor: isComputing ? 'wait' : cursor },
              onPointerDown: handlePointerDown, onPointerMove: handlePointerMove,
              onPointerUp: handlePointerUp, onContextMenu: e => e.preventDefault(),
              onWheel: handleWheel,
              onPointerLeave: () => { if(isPanningRef.current) {isPanningRef.current = false; setCursor('grab'); setViewTransform(panStartRef.current.transform);} }
            },
            React.createElement("canvas", { 
                ref: canvasRef, 
                width: settings.width, 
                height: settings.height, 
                className: "w-full h-full object-contain",
                style: { transform: `translate(${viewTransform.x}px, ${viewTransform.y}px) scale(${viewTransform.scale})` }
             }),
            isComputing && React.createElement("div", { className: "absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center" }, React.createElement("div", { className: "w-24 h-24 border-4 border-dashed rounded-full animate-spin border-cyan-400" }))
          );
        });

        // --- Main App Component ---
        const appReducer = (state, action) => {
          switch (action.type) {
            case 'SET_STATE': return { ...state, settings: action.payload };
            case 'SET_FRACTAL_TYPE': return { ...state, settings: { ...state.settings, fractalType: action.payload } };
            case 'SET_JULIA_C': return { ...state, settings: { ...state.settings, ...action.payload } };
            case 'SET_LIMITS': return { ...state, settings: { ...state.settings, ...action.payload } };
            case 'SET_IMAGE_SIZE': return { ...state, settings: { ...state.settings, ...action.payload } };
            case 'SET_MAX_ITERATIONS': return { ...state, settings: { ...state.settings, maxIterations: action.payload } };
            case 'SET_PALETTE': return { ...state, settings: { ...state.settings, palette: action.payload } };
            case 'SAVE_PALETTE_AND_CLOSE_EDITOR': return { ...state, settings: { ...state.settings, palette: action.payload }, isEditorOpen: false };
            case 'SET_PALETTE_LENGTH': return { ...state, settings: { ...state.settings, paletteLength: action.payload } };
            case 'SET_PALETTE_OFFSET': return { ...state, settings: { ...state.settings, paletteOffset: action.payload } };
            case 'SET_RENDER_OPTION': return { ...state, settings: { ...state.settings, [action.payload.key]: action.payload.value } };
            case 'SET_WORKER_COUNT': return { ...state, workerCount: action.payload };
            case 'SET_STATUS': return { ...state, status: action.payload };
            case 'SET_PROGRESS': return { ...state, progress: action.payload };
            case 'SET_IS_COMPUTING': return { ...state, isComputing: action.payload };
            case 'TOGGLE_EDITOR': return { ...state, isEditorOpen: !state.isEditorOpen };
            default: return state;
          }
        };

        const imageSizeOptions = {
            '800 600': "800x600 (4:3)", '1024 768': "1024x768 (4:3)",
            '1280 720': "1280x720 (16:9)", '1920 1080': "1920x1080 (16:9)",
            '600 800': "600x800 (Portrait)",
        };

        const App = () => {
            const initialState = {
              settings: defaultSettings,
              workerCount: navigator.hardwareConcurrency || 4,
              status: 'Ready.', progress: 0,
              isComputing: false, isEditorOpen: false,
            };
            const [undoState, dispatchWithUndo, canUndo, canRedo] = useUndoableReducer(appReducer, initialState);
            const canvasRef = useRef(null);
            const [zoomInFactor, setZoomInFactor] = useState(0.5);
            const [zoomOutFactor, setZoomOutFactor] = useState(2.0);
            const [isSidebarOpen, setIsSidebarOpen] = useState(true);
            const state = undoState.present;
            
            const setUndoPoint = useCallback((newSettings) => {
              dispatchWithUndo({ type: 'SET', newPresent: { ...state, settings: newSettings } });
            }, [dispatchWithUndo, state]);

            const handleRestoreDefaults = () => {
                setUndoPoint(state.settings);
                dispatchWithUndo({ type: 'RESET', newPresent: initialState });
            };

            const handleSizeChange = (val) => {
                const [newWidth, newHeight] = val.split(' ').map(Number);
                const { xmin, xmax, ymin, ymax } = state.settings;
                const [xminNum, xmaxNum, yminNum, ymaxNum] = [xmin, xmax, ymin, ymax].map(parseFloat);
                const centerX = (xminNum + xmaxNum) / 2, centerY = (yminNum + ymaxNum) / 2;
                const xRange = xmaxNum - xminNum;
                const newYRange = xRange / (newWidth / newHeight);
                const newYmin = centerY - newYRange / 2, newYmax = centerY + newYRange / 2;
                setUndoPoint(state.settings);
                dispatchWithUndo({ type: 'SET_IMAGE_SIZE', payload: { width: newWidth, height: newHeight, ymin: newYmin.toPrecision(16), ymax: newYmax.toPrecision(16) } });
            };
            
            const handleRandomPalette = () => {
                const c = [Math.random(), Math.random(), Math.random()];
                const stops = [{pos: 0, color: c}];
                for (let i = 1; i <= 5; i++) {
                    stops.push({ pos: i/6, color: [Math.random(), Math.random(), Math.random()] });
                }
                stops.push({ pos: 1, color: c });
                const randomPalette = { colorType: 'RGB', stops };
                setUndoPoint(state.settings);
                dispatchWithUndo({ type: 'SET_PALETTE', payload: randomPalette });
            };

            const handleSaveImage = () => {
                const canvas = canvasRef.current?.getCanvas();
                if (canvas) {
                    const link = document.createElement('a');
                    link.download = `${state.settings.fractalType.toLowerCase()}-explorer.png`;
                    link.href = canvas.toDataURL('image/png');
                    link.click();
                }
            };
            
            const currentPaletteName = Object.keys(standardPalettes).find(key => JSON.stringify(standardPalettes[key]) === JSON.stringify(state.settings.palette)) || 'Custom';

            const JuliaSetControls = () => {
                if (state.settings.fractalType !== 'Julia') return null;
                return React.createElement(ControlGroup, { title: "Julia Set Parameters" },
                    React.createElement(LabelInput, { label: "C (real)" }, 
                        React.createElement(Input, { type: "number", value: state.settings.cx, onChange: e => dispatchWithUndo({ type: 'SET_JULIA_C', payload: { cx: e.target.value } }), disabled: state.isComputing, step: "0.001" })
                    ),
                    React.createElement(LabelInput, { label: "C (imaginary)" }, 
                        React.createElement(Input, { type: "number", value: state.settings.cy, onChange: e => dispatchWithUndo({ type: 'SET_JULIA_C', payload: { cy: e.target.value } }), disabled: state.isComputing, step: "0.001" })
                    )
                );
            };
            
            return React.createElement("div", { className: "h-screen w-screen flex flex-col bg-gray-900 overflow-hidden" },
                React.createElement("header", { className: "flex-shrink-0 bg-gray-800 border-b border-gray-700 p-2 flex items-center justify-between z-10" },
                    React.createElement("div", { className: "flex items-center gap-4" },
                        React.createElement("button", { onClick: () => setIsSidebarOpen(!isSidebarOpen), title: isSidebarOpen ? "Collapse Sidebar" : "Expand Sidebar", className: "p-1 rounded-md hover:bg-gray-700 transition-colors text-gray-300 hover:text-white" },
                           React.createElement(SidebarToggleIcon, { isOpen: isSidebarOpen })
                        ),
                        React.createElement("h1", { className: "text-xl font-bold text-cyan-300" }, "Fractal Explorer")
                    ),
                    React.createElement("div", { className: "flex items-center space-x-2" },
                      React.createElement(Button, { onClick: () => dispatchWithUndo({ type: 'UNDO' }), disabled: !canUndo, title: "Undo" }, React.createElement(UndoIcon, null)),
                      React.createElement(Button, { onClick: () => dispatchWithUndo({ type: 'REDO' }), disabled: !canRedo, title: "Redo" }, React.createElement(RedoIcon, null))
                    )
                ),
                React.createElement("main", { className: "flex-1 flex overflow-hidden" },
                    React.createElement("aside", { className: `flex-shrink-0 bg-gray-800 overflow-y-auto transition-all duration-300 ease-in-out ${isSidebarOpen ? 'w-80' : 'w-0 -translate-x-full'}` },
                       React.createElement("div", { className: "w-80" },
                           React.createElement(ControlGroup, { title: "Fractal Type" },
                              React.createElement("div", {className: "grid grid-cols-2 gap-2"},
                                React.createElement(Button, {onClick: () => { setUndoPoint(state.settings); dispatchWithUndo({type: 'SET_FRACTAL_TYPE', payload: 'Mandelbrot'})}, disabled: state.settings.fractalType === 'Mandelbrot', className: state.settings.fractalType === 'Mandelbrot' ? '!bg-cyan-600' : ''}, "Mandelbrot"),
                                React.createElement(Button, {onClick: () => { setUndoPoint(state.settings); dispatchWithUndo({type: 'SET_FRACTAL_TYPE', payload: 'Julia'})}, disabled: state.settings.fractalType === 'Julia', className: state.settings.fractalType === 'Julia' ? '!bg-cyan-600' : ''}, "Julia")
                              )
                           ),
                           React.createElement(ControlGroup, { title: "View" },
                             React.createElement(LabelInput, { label: "Image Size" }, React.createElement(Select, { value: `${state.settings.width} ${state.settings.height}`, onChange: e => handleSizeChange(e.target.value), disabled: state.isComputing }, Object.entries(imageSizeOptions).map(([val, text]) => React.createElement("option", { key: val, value: val }, text)))),
                             React.createElement("div", { className: "grid grid-cols-2 gap-2" },
                                React.createElement(Button, { onClick: handleRestoreDefaults, disabled: state.isComputing }, "Restore Defaults"),
                                React.createElement(Button, { onClick: handleSaveImage, disabled: state.isComputing }, React.createElement(SaveIcon, null), " Save Image")
                             ),
                             React.createElement(Button, { onClick: () => canvasRef.current?.stopComputation(), disabled: !state.isComputing, className: "w-full !bg-red-600 hover:!bg-red-500" }, "Stop")
                           ),
                           React.createElement(ControlGroup, { title: "Navigation" }, React.createElement("div", { className: "text-xs text-gray-400 space-y-2" }, 
                               React.createElement("p", null, React.createElement("strong", { className: "text-gray-200" }, "Zoom:"), " Use the mouse wheel to zoom in and out."),
                               React.createElement("p", null, React.createElement("strong", { className: "text-gray-200" }, "Pan:"), " Click and drag with the left mouse button."),
                               React.createElement("p", null, React.createElement("strong", { className: "text-gray-200" }, "Select Julia Set:"), " Shift-click on the Mandelbrot view to generate a Julia set.")
                           )),
                           React.createElement(ControlGroup, { title: "Zoom Controls" },
                             React.createElement(LabelInput, { label: "Zoom In By" }, React.createElement(Select, { value: zoomInFactor, onChange: e => setZoomInFactor(Number(e.target.value)), disabled: state.isComputing }, React.createElement("option", { value: "0.5" }, "2x"), React.createElement("option", { value: "0.2" }, "5x"), React.createElement("option", { value: "0.1" }, "10x"))), React.createElement(Button, { onClick: () => canvasRef.current?.zoom(zoomInFactor), disabled: state.isComputing }, "Zoom In"),
                             React.createElement(LabelInput, { label: "Zoom Out By" }, React.createElement(Select, { value: zoomOutFactor, onChange: e => setZoomOutFactor(Number(e.target.value)), disabled: state.isComputing }, React.createElement("option", { value: "2" }, "2x"), React.createElement("option", { value: "5" }, "5x"), React.createElement("option", { value: "10" }, "10x"))), React.createElement(Button, { onClick: () => canvasRef.current?.zoom(zoomOutFactor), disabled: state.isComputing }, "Zoom Out")
                           ),
                           React.createElement(JuliaSetControls, null),
                           React.createElement(ControlGroup, { title: "Render" },
                              React.createElement(LabelInput, { label: "Max Iterations" }, React.createElement(Input, { type: "number", value: state.settings.maxIterations, onChange: e => { setUndoPoint(state.settings); dispatchWithUndo({ type: 'SET_MAX_ITERATIONS', payload: parseInt(e.target.value, 10) }) }, disabled: state.isComputing, min: "50", step: "50" })),
                               React.createElement(LabelInput, { label: "Workers" }, React.createElement(Select, { value: state.workerCount, onChange: e => dispatchWithUndo({ type: 'SET_WORKER_COUNT', payload: parseInt(e.target.value, 10) }), disabled: state.isComputing }, [1, 2, 4, 6, 8, 12, 16].filter(c => c <= (navigator.hardwareConcurrency || 16)).map(c => React.createElement("option", { key: c, value: c }, c)))),
                               React.createElement("label", { className: "flex items-center space-x-2 text-sm" }, React.createElement("input", { type: "checkbox", className: "form-checkbox bg-gray-700 border-gray-600 text-cyan-400 focus:ring-cyan-500", checked: state.settings.interlaced, onChange: e => dispatchWithUndo({ type: 'SET_RENDER_OPTION', payload: { key: 'interlaced', value: e.target.checked } }) }), React.createElement("span", null, "Interlaced Draw"))
                           ),
                           React.createElement(ControlGroup, { title: "Palette" },
                              React.createElement(LabelInput, { label: "Palette Length" }, React.createElement(Input, { type: "number", value: state.settings.paletteLength, onChange: e => {setUndoPoint(state.settings); dispatchWithUndo({type: 'SET_PALETTE_LENGTH', payload: parseInt(e.target.value)})}, disabled: state.isComputing, min: "2", step: "10" })),
                               React.createElement(LabelInput, { label: "Palette Offset (%)" }, React.createElement(Input, { type: "range", min: "0", max: "100", value: state.settings.paletteOffset * 100, onChange: e => dispatchWithUndo({ type: 'SET_PALETTE_OFFSET', payload: parseInt(e.target.value) / 100 }) })),
                              React.createElement(LabelInput, { label: "Standard Palette" }, React.createElement(Select, { value: currentPaletteName, onChange: e => {setUndoPoint(state.settings); dispatchWithUndo({type: 'SET_PALETTE', payload: standardPalettes[e.target.value]})}}, Object.keys(standardPalettes).map(name => React.createElement("option", { key: name, value: name }, name)), currentPaletteName === 'Custom' && React.createElement("option", { key: "Custom", value: "Custom", disabled: true }, "Custom"))),
                              React.createElement("div", { className: "grid grid-cols-2 gap-2" },
                                React.createElement(Button, { onClick: handleRandomPalette, disabled: state.isComputing }, React.createElement(RandomIcon, null), " Randomize"),
                                React.createElement(Button, { onClick: () => dispatchWithUndo({ type: 'TOGGLE_EDITOR' }) }, React.createElement(SettingsIcon, null), " Edit Palette")
                              )
                           )
                       )
                    ),
                    React.createElement("div", { className: "flex-1 flex flex-col bg-gray-900" },
                        React.createElement("div", { className: "flex-1 relative bg-black flex items-center justify-center" }, React.createElement(FractalCanvas, { ref: canvasRef, state: state, dispatch: dispatchWithUndo, setUndoPoint: setUndoPoint })),
                        React.createElement("footer", { className: "flex-shrink-0 bg-gray-800 border-t border-gray-700 px-4 py-1.5 flex items-center justify-between text-xs" },
                            React.createElement("div", { className: "text-gray-400" }, state.status),
                            React.createElement("div", { className: "w-48 bg-gray-700 rounded-full h-2.5" }, React.createElement("div", { className: "bg-cyan-400 h-2.5 rounded-full", style: { width: `${state.progress * 100}%`, transition: state.progress > 0.01 ? 'width 0.1s' : 'none' }}))
                        )
                    )
                ),
                state.isEditorOpen && React.createElement(PaletteEditor, {
                    palette: state.settings.palette,
                    onSave: (newPalette) => {
                        setUndoPoint(state.settings);
                        dispatchWithUndo({ type: 'SAVE_PALETTE_AND_CLOSE_EDITOR', payload: newPalette });
                    },
                    onCancel: () => dispatchWithUndo({ type: 'TOGGLE_EDITOR' })
                })
            );
        };

        // --- Mount Application ---
        const rootElement = document.getElementById('root');
        if (!rootElement) throw new Error("Could not find root element");
        const root = ReactDOM.createRoot(rootElement);
        root.render(React.createElement(React.StrictMode, null, React.createElement(App, null)));
    </script>
</body>
</html>
