<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Celestial Chess Game</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- React and ReactDOM -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <!-- Babel for JSX/TSX transpilation -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    body {
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      font-family: sans-serif;
    }
  </style>
</head>
<body class="bg-gradient-to-br from-indigo-900 to-purple-900">
  <div id="root"></div>

  <script type="text/babel" data-presets="react,typescript">
    // --- From types.ts ---
    const PieceType = {
      PAWN: 'PAWN',
      ROOK: 'ROOK',
      KNIGHT: 'KNIGHT',
      BISHOP: 'BISHOP',
      QUEEN: 'QUEEN',
      KING: 'KING',
    };

    const PlayerColor = {
      WHITE: 'WHITE',
      BLACK: 'BLACK',
    };

    const GameStatus = {
      IN_PROGRESS: 'IN_PROGRESS',
      CHECK: 'CHECK',
      CHECKMATE: 'CHECKMATE',
      STALEMATE: 'STALEMATE',
      PROMOTION: 'PROMOTION',
    };

    // --- From constants.ts ---
    const PIECE_UNICODE = {
      [PlayerColor.WHITE]: {
        [PieceType.KING]: '♔',
        [PieceType.QUEEN]: '♕',
        [PieceType.ROOK]: '♖',
        [PieceType.BISHOP]: '♗',
        [PieceType.KNIGHT]: '♘',
        [PieceType.PAWN]: '♙',
      },
      [PlayerColor.BLACK]: {
        [PieceType.KING]: '♚',
        [PieceType.QUEEN]: '♛',
        [PieceType.ROOK]: '♜',
        [PieceType.BISHOP]: '♝',
        [PieceType.KNIGHT]: '♞',
        [PieceType.PAWN]: '♟︎',
      },
    };

    const PIECE_VALUES = {
      [PieceType.KING]: 20000,
      [PieceType.QUEEN]: 90,
      [PieceType.ROOK]: 50,
      [PieceType.BISHOP]: 30,
      [PieceType.KNIGHT]: 30,
      [PieceType.PAWN]: 10,
    };

    const createInitialBoard = () => {
      const board = Array(8).fill(null).map(() => Array(8).fill(null));

      const placePiece = (row, col, piece) => {
        board[row][col] = { ...piece, hasMoved: false };
      };

      // Black pieces
      placePiece(0, 0, { type: PieceType.ROOK, color: PlayerColor.BLACK });
      placePiece(0, 1, { type: PieceType.KNIGHT, color: PlayerColor.BLACK });
      placePiece(0, 2, { type: PieceType.BISHOP, color: PlayerColor.BLACK });
      placePiece(0, 3, { type: PieceType.QUEEN, color: PlayerColor.BLACK });
      placePiece(0, 4, { type: PieceType.KING, color: PlayerColor.BLACK });
      placePiece(0, 5, { type: PieceType.BISHOP, color: PlayerColor.BLACK });
      placePiece(0, 6, { type: PieceType.KNIGHT, color: PlayerColor.BLACK });
      placePiece(0, 7, { type: PieceType.ROOK, color: PlayerColor.BLACK });
      for (let i = 0; i < 8; i++) {
        placePiece(1, i, { type: PieceType.PAWN, color: PlayerColor.BLACK });
      }

      // White pieces
      placePiece(7, 0, { type: PieceType.ROOK, color: PlayerColor.WHITE });
      placePiece(7, 1, { type: PieceType.KNIGHT, color: PlayerColor.WHITE });
      placePiece(7, 2, { type: PieceType.BISHOP, color: PlayerColor.WHITE });
      placePiece(7, 3, { type: PieceType.QUEEN, color: PlayerColor.WHITE });
      placePiece(7, 4, { type: PieceType.KING, color: PlayerColor.WHITE });
      placePiece(7, 5, { type: PieceType.BISHOP, color: PlayerColor.WHITE });
      placePiece(7, 6, { type: PieceType.KNIGHT, color: PlayerColor.WHITE });
      placePiece(7, 7, { type: PieceType.ROOK, color: PlayerColor.WHITE });
      for (let i = 0; i < 8; i++) {
        placePiece(6, i, { type: PieceType.PAWN, color: PlayerColor.WHITE });
      }

      return board;
    };

    // --- From services/chessLogic.ts ---
    const isPositionOnBoard = (row, col) => {
      return row >= 0 && row < 8 && col >= 0 && col < 8;
    };

    const isSquareAttacked = (board, position, attackerColor) => {
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const piece = board[r][c];
          if (piece && piece.color === attackerColor) {
            const moves = getPieceMoves(board, piece, { row: r, col: c }, true);
            if (moves.some(move => move.row === position.row && move.col === position.col)) {
              return true;
            }
          }
        }
      }
      return false;
    };

    const getPieceMoves = (board, piece, position, forAttackCheck = false) => {
      const { row, col } = position;
      const moves = [];

      const addMove = (r, c, canCapture = true) => {
        if (isPositionOnBoard(r, c)) {
          const targetSquare = board[r][c];
          if (targetSquare === null) {
            moves.push({ row: r, col: c });
            return true;
          } else if (canCapture && targetSquare.color !== piece.color) {
            moves.push({ row: r, col: c });
            return false;
          }
        }
        return false;
      };

      const addSlidingMoves = (directions) => {
        directions.forEach(([dr, dc]) => {
          let r = row + dr;
          let c = col + dc;
          while (isPositionOnBoard(r, c)) {
            const targetSquare = board[r][c];
            if (targetSquare === null) {
              moves.push({ row: r, col: c });
            } else {
              if (targetSquare.color !== piece.color) {
                moves.push({ row: r, col: c });
              }
              break;
            }
            r += dr;
            c += dc;
          }
        });
      };

      switch (piece.type) {
        case PieceType.PAWN:
          const direction = piece.color === PlayerColor.WHITE ? -1 : 1;
          const startRow = piece.color === PlayerColor.WHITE ? 6 : 1;

          if (isPositionOnBoard(row + direction, col) && !board[row + direction][col]) {
            addMove(row + direction, col, false);
            if (row === startRow && isPositionOnBoard(row + 2 * direction, col) && !board[row + 2 * direction][col]) {
              addMove(row + 2 * direction, col, false);
            }
          }

          [-1, 1].forEach(dc => {
            if (isPositionOnBoard(row + direction, col + dc)) {
              const target = board[row + direction][col + dc];
              if (target && target.color !== piece.color) {
                moves.push({ row: row + direction, col: col + dc });
              }
            }
          });
          break;

        case PieceType.ROOK:
          addSlidingMoves([[0, 1], [0, -1], [1, 0], [-1, 0]]);
          break;

        case PieceType.KNIGHT:
          [[2, 1], [2, -1], [-2, 1], [-2, -1], [1, 2], [1, -2], [-1, 2], [-1, -2]]
            .forEach(([dr, dc]) => addMove(row + dr, col + dc));
          break;

        case PieceType.BISHOP:
          addSlidingMoves([[1, 1], [1, -1], [-1, 1], [-1, -1]]);
          break;

        case PieceType.QUEEN:
          addSlidingMoves([[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]]);
          break;

        case PieceType.KING:
          [[-1,-1], [-1,0], [-1,1], [0,-1], [0,1], [1,-1], [1,0], [1,1]]
            .forEach(([dr, dc]) => addMove(row + dr, col + dc));

          // Castling
          if (!forAttackCheck && !piece.hasMoved && !isKingInCheck(board, piece.color)) {
            const opponentColor = piece.color === PlayerColor.WHITE ? PlayerColor.BLACK : PlayerColor.WHITE;
            
            // Kingside castling
            const kingsideRook = board[row][7];
            if (kingsideRook && kingsideRook.type === PieceType.ROOK && !kingsideRook.hasMoved &&
                !board[row][5] && !board[row][6] &&
                !isSquareAttacked(board, {row, col: 5}, opponentColor) &&
                !isSquareAttacked(board, {row, col: 6}, opponentColor)) {
              moves.push({ row, col: 6 });
            }

            // Queenside castling
            const queensideRook = board[row][0];
            if (queensideRook && queensideRook.type === PieceType.ROOK && !queensideRook.hasMoved &&
                !board[row][1] && !board[row][2] && !board[row][3] &&
                !isSquareAttacked(board, {row, col: 2}, opponentColor) &&
                !isSquareAttacked(board, {row, col: 3}, opponentColor)) {
              moves.push({ row, col: 2 });
            }
          }
          break;
      }

      return moves;
    };

    const isKingInCheck = (board, kingColor) => {
      let kingPosition = null;
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const piece = board[r][c];
          if (piece && piece.type === PieceType.KING && piece.color === kingColor) {
            kingPosition = { row: r, col: c };
            break;
          }
        }
        if (kingPosition) break;
      }

      if (!kingPosition) return false;

      const opponentColor = kingColor === PlayerColor.WHITE ? PlayerColor.BLACK : PlayerColor.WHITE;
      return isSquareAttacked(board, kingPosition, opponentColor);
    };

    const getValidMoves = (board, piece, position) => {
      const pseudoLegalMoves = getPieceMoves(board, piece, position);
      return pseudoLegalMoves.filter(move => {
        const newBoard = board.map(row => [...row]);

        // Simulate move
        newBoard[move.row][move.col] = piece;
        newBoard[position.row][position.col] = null;
        
        // Simulate castling rook move for check validation
        if (piece.type === PieceType.KING && Math.abs(position.col - move.col) === 2) {
            if (move.col === 6) { // Kingside
                newBoard[position.row][5] = newBoard[position.row][7];
                newBoard[position.row][7] = null;
            } else { // Queenside
                newBoard[position.row][3] = newBoard[position.row][0];
                newBoard[position.row][0] = null;
            }
        }

        return !isKingInCheck(newBoard, piece.color);
      });
    };

    const hasAnyValidMoves = (board, color) => {
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const piece = board[r][c];
          if (piece && piece.color === color) {
            if (getValidMoves(board, piece, { row: r, col: c }).length > 0) {
              return true;
            }
          }
        }
      }
      return false;
    };
    
    const evaluateBoard = (board) => {
      let totalEvaluation = 0;
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const piece = board[r][c];
          if (piece) {
            const value = PIECE_VALUES[piece.type];
            totalEvaluation += piece.color === PlayerColor.WHITE ? value : -value;
          }
        }
      }
      return totalEvaluation;
    };

    const findBestMove = (board, color) => {
      const allMoves = [];
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const piece = board[r][c];
          if (piece && piece.color === color) {
            const validMoves = getValidMoves(board, piece, { row: r, col: c });
            for (const move of validMoves) {
              allMoves.push({ from: { row: r, col: c }, to: move, piece });
            }
          }
        }
      }

      if (allMoves.length === 0) return null;

      let bestMoves = [];
      let bestScore = color === PlayerColor.WHITE ? -Infinity : Infinity;

      for (const move of allMoves) {
        const { from, to, piece } = move;
        const newBoard = board.map(row => [...row]);
        newBoard[to.row][to.col] = piece;
        newBoard[from.row][from.col] = null;

        const score = evaluateBoard(newBoard);

        if (color === PlayerColor.WHITE) {
          if (score > bestScore) {
            bestScore = score;
            bestMoves = [{ from, to }];
          } else if (score === bestScore) {
            bestMoves.push({ from, to });
          }
        } else { // BLACK
          if (score < bestScore) {
            bestScore = score;
            bestMoves = [{ from, to }];
          } else if (score === bestScore) {
            bestMoves.push({ from, to });
          }
        }
      }

      if (bestMoves.length > 0) {
        return bestMoves[Math.floor(Math.random() * bestMoves.length)];
      }

      return null;
    };

    // --- From components/Square.tsx ---
    const Square = React.memo(({ square, position, isSelected, isValidMove, onSquareClick }) => {
      const { row, col } = position;
      const isLight = (row + col) % 2 !== 0;

      const bgClass = isLight ? 'bg-indigo-800/50' : 'bg-purple-900/50';
      const pieceColorClass = square?.color === PlayerColor.WHITE ? 'text-cyan-200' : 'text-fuchsia-400';
      const pieceGlow = square?.color === PlayerColor.WHITE ? 'drop-shadow-[0_0_8px_rgba(100,220,255,0.9)]' : 'drop-shadow-[0_0_8px_rgba(255,100,220,0.9)]';

      return (
        <div
          className={`w-full h-full flex justify-center items-center relative transition-shadow duration-300 ${bgClass}`}
          onClick={() => onSquareClick(position)}
          style={{
            boxShadow: isSelected ? 'inset 0 0 15px rgba(50, 200, 255, 0.7), 0 0 25px rgba(50, 200, 255, 0.9)' : 'none'
          }}
        >
          {isValidMove && (
            <div className="absolute w-1/3 h-1/3 bg-cyan-300/50 rounded-full animate-pulse"></div>
          )}
          {square && (
            <span className={`text-5xl md:text-6xl cursor-pointer select-none transition-transform duration-200 hover:scale-110 ${pieceColorClass} ${pieceGlow}`}>
              {PIECE_UNICODE[square.color][square.type]}
            </span>
          )}
        </div>
      );
    });

    // --- From components/Board.tsx ---
    const Board = ({ board, selectedPosition, validMoves, onSquareClick, isBoardDisabled }) => {
      return (
        <div className={`grid grid-cols-8 grid-rows-8 aspect-square w-full max-w-[calc(100vh-10rem)] shadow-2xl rounded-lg overflow-hidden border-4 border-cyan-300/50 transition-opacity ${isBoardDisabled ? 'pointer-events-none opacity-60' : ''}`}
            style={{
              boxShadow: '0 0 20px rgba(0, 255, 255, 0.4), 0 0 30px rgba(0, 255, 255, 0.3)',
            }}
        >
          {board.map((row, rowIndex) =>
            row.map((square, colIndex) => {
              const position = { row: rowIndex, col: colIndex };
              const isSelected = selectedPosition?.row === rowIndex && selectedPosition?.col === colIndex;
              const isValidMove = validMoves.some(move => move.row === rowIndex && move.col === colIndex);
              return (
                <Square
                  key={`${rowIndex}-${colIndex}`}
                  square={square}
                  position={position}
                  isSelected={isSelected}
                  isValidMove={isValidMove}
                  onSquareClick={onSquareClick}
                />
              );
            })
          )}
        </div>
      );
    };

    // --- From App.tsx ---
    const App = () => {
      const { useState, useCallback, useMemo, useEffect } = React;
      
      const [board, setBoard] = useState(createInitialBoard());
      const [turn, setTurn] = useState(PlayerColor.WHITE);
      const [selectedPosition, setSelectedPosition] = useState(null);
      const [validMoves, setValidMoves] = useState([]);
      const [status, setStatus] = useState(GameStatus.IN_PROGRESS);
      const [promotion, setPromotion] = useState(null);
      const [gameState, setGameState] = useState('menu');
      const [gameMode, setGameMode] = useState('pvp');
      const [isComputerThinking, setIsComputerThinking] = useState(false);
      const [history, setHistory] = useState([]);
      
      const playerColor = PlayerColor.WHITE;
      const computerColor = PlayerColor.BLACK;

      const resetGame = useCallback(() => {
        setBoard(createInitialBoard());
        setTurn(PlayerColor.WHITE);
        setSelectedPosition(null);
        setValidMoves([]);
        setStatus(GameStatus.IN_PROGRESS);
        setPromotion(null);
        setIsComputerThinking(false);
        setHistory([]);
      }, []);
      
      const startGame = useCallback((mode) => {
        setGameMode(mode);
        setGameState('playing');
        resetGame();
      }, [resetGame]);
      
      const backToMenu = useCallback(() => setGameState('menu'), []);

      const updateStatusAndTurn = useCallback((currentBoard, nextTurn) => {
        const kingInCheck = isKingInCheck(currentBoard, nextTurn);
        const anyMoves = hasAnyValidMoves(currentBoard, nextTurn);

        if (kingInCheck && !anyMoves) setStatus(GameStatus.CHECKMATE);
        else if (!kingInCheck && !anyMoves) setStatus(GameStatus.STALEMATE);
        else if (kingInCheck) setStatus(GameStatus.CHECK);
        else setStatus(GameStatus.IN_PROGRESS);

        setTurn(nextTurn);
      }, []);

      const handleMove = useCallback((from, to) => {
        const piece = board[from.row][from.col];
        const newBoard = board.map(row => [...row]);
        
        setHistory(prev => [...prev, { board, turn, status }]);

        // Update piece with hasMoved
        const movedPiece = { ...piece, hasMoved: true };
        newBoard[to.row][to.col] = movedPiece;
        newBoard[from.row][from.col] = null;

        // Handle castling rook move
        if (piece.type === PieceType.KING && Math.abs(from.col - to.col) === 2) {
          if (to.col === 6) { // Kingside
            const rook = newBoard[from.row][7];
            newBoard[from.row][5] = { ...rook, hasMoved: true };
            newBoard[from.row][7] = null;
          } else if (to.col === 2) { // Queenside
            const rook = newBoard[from.row][0];
            newBoard[from.row][3] = { ...rook, hasMoved: true };
            newBoard[from.row][0] = null;
          }
        }

        setBoard(newBoard);
        setSelectedPosition(null);
        setValidMoves([]);

        if (piece.type === PieceType.PAWN && (to.row === 0 || to.row === 7)) {
            setPromotion({ position: to, piece: movedPiece });
        } else {
            updateStatusAndTurn(newBoard, turn === PlayerColor.WHITE ? PlayerColor.BLACK : PlayerColor.WHITE);
        }
      }, [board, turn, updateStatusAndTurn, status]);

      const handlePromotion = useCallback((promotionType) => {
        if (!promotion) return;
        const { position, piece } = promotion;
        const newBoard = board.map(r => [...r]);
        newBoard[position.row][position.col] = { type: promotionType, color: piece.color, hasMoved: true };
        
        setBoard(newBoard);
        setPromotion(null);
        // Do not push to history here, as the move was already recorded in handleMove
        updateStatusAndTurn(newBoard, turn === PlayerColor.WHITE ? PlayerColor.BLACK : PlayerColor.WHITE);
      }, [promotion, board, turn, updateStatusAndTurn]);

      const handleUndo = useCallback(() => {
        if (history.length === 0) return;

        let lastState;
        let newHistory = [...history];

        // In PVC, undo both computer's and player's move to return to player's turn
        if (gameMode === 'pvc' && turn === playerColor && newHistory.length >= 2) {
            newHistory.pop(); 
        }
        lastState = newHistory.pop();
        
        setHistory(newHistory);
        
        if (lastState) {
          setBoard(lastState.board);
          setTurn(lastState.turn);
          setStatus(lastState.status);
          setSelectedPosition(null);
          setValidMoves([]);
          setPromotion(null);
          setIsComputerThinking(false);
        }
      }, [history, gameMode, turn, playerColor]);

      useEffect(() => {
        if (
          gameState === 'playing' && gameMode === 'pvc' && turn === computerColor &&
          (status === GameStatus.IN_PROGRESS || status === GameStatus.CHECK) && !promotion
        ) {
          setIsComputerThinking(true);
          const timer = setTimeout(() => {
            const bestMove = findBestMove(board, computerColor);
            if (bestMove) {
              handleMove(bestMove.from, bestMove.to);
            }
            setIsComputerThinking(false);
          }, 1000);
          return () => clearTimeout(timer);
        }
      }, [turn, status, gameMode, gameState, board, handleMove, promotion, computerColor]);

      const onSquareClick = useCallback((position) => {
        if (status === GameStatus.CHECKMATE || status === GameStatus.STALEMATE || promotion || isComputerThinking || (gameMode === 'pvc' && turn !== playerColor)) return;

        const clickedPiece = board[position.row][position.col];

        if (selectedPosition) {
          if (validMoves.some(move => move.row === position.row && move.col === position.col)) {
            handleMove(selectedPosition, position);
          } else if (clickedPiece && clickedPiece.color === turn) {
            setSelectedPosition(position);
            setValidMoves(getValidMoves(board, clickedPiece, position));
          } else {
            setSelectedPosition(null);
            setValidMoves([]);
          }
        } else if (clickedPiece && clickedPiece.color === turn) {
          setSelectedPosition(position);
          setValidMoves(getValidMoves(board, clickedPiece, position));
        }
      }, [selectedPosition, validMoves, turn, board, status, handleMove, promotion, gameMode, playerColor, isComputerThinking]);

      const statusMessage = useMemo(() => {
        if (isComputerThinking) return "Computer is thinking...";
        if (status === GameStatus.CHECKMATE) return `Checkmate! ${turn === PlayerColor.WHITE ? 'Black' : 'White'} wins!`;
        if (status === GameStatus.STALEMATE) return "Stalemate! It's a draw.";
        if (status === GameStatus.CHECK) return `${turn} is in Check!`;
        return `${turn}'s Turn`;
      }, [status, turn, isComputerThinking]);

      const PromotionModal = () => {
        if (!promotion) return null;
        const color = promotion.piece.color;
        const promotionPieces = [PieceType.QUEEN, PieceType.ROOK, PieceType.BISHOP, PieceType.KNIGHT];

        return (
            <div className="absolute inset-0 bg-black bg-opacity-80 backdrop-blur-sm flex justify-center items-center z-50">
                <div className="bg-slate-800/50 border border-cyan-300/20 p-8 rounded-lg text-white text-center shadow-2xl"
                  style={{boxShadow: '0 0 30px rgba(125, 211, 252, 0.3)'}} >
                    <h2 className="text-2xl font-bold mb-4 text-cyan-200">Promote your Pawn!</h2>
                    <div className="flex justify-center space-x-4">
                        {promotionPieces.map(type => (
                            <button key={type} onClick={() => handlePromotion(type)} className="bg-slate-700/50 hover:bg-slate-600/50 rounded-lg p-2 transition-transform duration-200 hover:scale-110">
                                <span className="text-6xl" style={{filter: 'drop-shadow(0 0 5px rgba(255,255,255,0.7))'}}>{PIECE_UNICODE[color][type]}</span>
                            </button>
                        ))}
                    </div>
                </div>
            </div>
        );
      };

      if (gameState === 'menu') {
        return (
          <main className="text-white min-h-screen flex flex-col items-center justify-center p-4">
            <div className="text-center">
              <h1 className="text-6xl font-bold mb-4 text-cyan-300 drop-shadow-[0_0_10px_rgba(100,220,255,0.8)]">Celestial Chess</h1>
              <p className="text-xl mb-8 text-violet-300">Choose your battle</p>
              <div className="space-y-4">
                <button onClick={() => startGame('pvc')} className="w-64 bg-cyan-400/20 hover:bg-cyan-400/40 border border-cyan-300 text-cyan-200 font-bold py-3 px-6 rounded-lg transition-all duration-300 shadow-[0_0_15px_rgba(100,220,255,0.5)] hover:shadow-[0_0_25px_rgba(100,220,255,0.8)]">
                  Player vs Computer
                </button>
                <button onClick={() => startGame('pvp')} className="w-64 bg-violet-400/20 hover:bg-violet-400/40 border border-violet-300 text-violet-200 font-bold py-3 px-6 rounded-lg transition-all duration-300 shadow-[0_0_15px_rgba(200,150,255,0.5)] hover:shadow-[0_0_25px_rgba(200,150,255,0.8)]">
                  Player vs Player
                </button>
              </div>
            </div>
          </main>
        );
      }

      return (
        <main className="text-white min-h-screen flex flex-col items-center justify-center p-4">
          <div className="relative w-full max-w-5xl flex flex-col md:flex-row items-center md:items-start justify-center gap-8">
            <PromotionModal />
            <div className="w-full md:w-auto order-2 md:order-1 flex flex-col items-center">
                <h1 className="text-4xl font-bold mb-2 text-cyan-300 drop-shadow-[0_0_10px_rgba(100,220,255,0.8)]">Celestial Chess</h1>
                <div className="bg-slate-800/50 backdrop-blur-sm border border-cyan-300/20 p-4 rounded-lg shadow-lg text-center w-64 h-20 flex items-center justify-center mb-4">
                  <p className="text-xl font-semibold capitalize text-violet-200">{statusMessage}</p>
                </div>
                <div className="grid grid-cols-2 gap-2 w-64">
                   <button onClick={resetGame} className="bg-cyan-400/20 hover:bg-cyan-400/40 border border-cyan-300 text-cyan-200 font-bold py-2 px-4 rounded-lg transition-all duration-300 shadow-[0_0_10px_rgba(100,220,255,0.3)]">
                      Reset
                  </button>
                  <button onClick={backToMenu} className="bg-violet-400/20 hover:bg-violet-400/40 border border-violet-300 text-violet-200 font-bold py-2 px-4 rounded-lg transition-all duration-300 shadow-[0_0_10px_rgba(200,150,255,0.3)]">
                      Menu
                  </button>
                  <button 
                    onClick={handleUndo} 
                    disabled={history.length === 0}
                    className="col-span-2 bg-amber-400/20 hover:bg-amber-400/40 border border-amber-300 text-amber-200 font-bold py-2 px-4 rounded-lg transition-all duration-300 shadow-[0_0_10px_rgba(251,191,36,0.3)] disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:bg-amber-400/20 disabled:shadow-[0_0_10px_rgba(251,191,36,0.3)]">
                      Undo
                  </button>
                </div>
            </div>
            <div className="w-full md:w-auto order-1 md:order-2">
              <Board 
                board={board}
                selectedPosition={selectedPosition}
                validMoves={validMoves}
                onSquareClick={onSquareClick}
                isBoardDisabled={isComputerThinking || (gameMode === 'pvc' && turn !== playerColor)}
              />
            </div>
          </div>
        </main>
      );
    };

    // --- From index.tsx ---
    const rootElement = document.getElementById('root');
    const root = ReactDOM.createRoot(rootElement);
    root.render(
      <React.StrictMode>
        <App />
      </React.StrictMode>
    );
  </script>
</body>
</html>