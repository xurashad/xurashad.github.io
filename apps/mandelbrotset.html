<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mandelbrot Explorer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      body {
        overscroll-behavior: none;
      }
      /* Style for details/summary arrow */
      details[open] > summary .details-arrow {
        transform: rotate(180deg);
      }
      /* Simple modal styles */
      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.75);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 50;
      }
    </style>
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client"
      }
    }
    </script>
<link rel="stylesheet" href="/index.css">
</head>
<body class="bg-gray-900 text-white font-sans">
    <div id="root"></div>
    <script type="module">
        import React, { useState, useEffect, useReducer, useCallback, useRef, forwardRef, useImperativeHandle } from 'react';
        import ReactDOM from 'react-dom/client';

        // --- Color Conversion Helpers ---
        const hexToRgb = (hex) => {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? [parseInt(result[1], 16) / 255, parseInt(result[2], 16) / 255, parseInt(result[3], 16) / 255] : [0, 0, 0];
        };
        const rgbToHex = (rgb) => "#" + rgb.map(c => Math.round(c * 255).toString(16).padStart(2, '0')).join('');

        // --- Mandelbrot Service Logic (from services/mandelbrotService.ts) ---
        const getWorkerScript = () => {
            return `
            const MAX_ZOOM_DEPTH_RATIO = 1e-15;

            function calculateMandelbrotRow(jobData) {
                const { row, settings } = jobData;
                const { width, height, xmin, xmax, ymin, ymax, maxIterations } = settings;

                const xminNum = parseFloat(xmin);
                const xmaxNum = parseFloat(xmax);
                const yminNum = parseFloat(ymin);
                const ymaxNum = parseFloat(ymax);

                const iterationCounts = new Int32Array(width);
                const dx = (xmaxNum - xminNum) / (width > 1 ? width - 1 : 1);
                const dy = (ymaxNum - yminNum) / (height > 1 ? height - 1 : 1);
                
                if (dx < MAX_ZOOM_DEPTH_RATIO || dy < MAX_ZOOM_DEPTH_RATIO) {
                  postMessage({
                      row: jobData.row,
                      jobId: jobData.jobId,
                      iterationCounts: new Int32Array(0),
                      error: 'Maximum zoom level reached for standard precision.'
                  });
                  return;
                }

                let y0 = ymaxNum - row * dy;

                for (let i = 0; i < width; i++) {
                    let x0 = xminNum + i * dx;
                    let x = 0.0;
                    let y = 0.0;
                    let iteration = 0;
                    
                    while (x * x + y * y <= 4 && iteration < maxIterations) {
                        let xtemp = x * x - y * y + x0;
                        y = 2 * x * y + y0;
                        x = xtemp;
                        iteration++;
                    }
                    
                    iterationCounts[i] = (iteration === maxIterations) ? -1 : iteration;
                }
                
                postMessage({
                    row: jobData.row,
                    jobId: jobData.jobId,
                    iterationCounts: iterationCounts
                });
            }

            self.onmessage = function(e) {
                calculateMandelbrotRow(e.data);
            };
            `;
        };

        function hsbToRgb(h, s, v) {
            h = (h - Math.floor(h)) * 360;
            let r=0, g=0, b=0;
            const i = Math.floor(h / 60);
            const f = h / 60 - i;
            const p = v * (1 - s);
            const q = v * (1 - f * s);
            const t = v * (1 - (1 - f) * s);
            switch (i % 6) {
                case 0: r = v; g = t; b = p; break;
                case 1: r = q; g = v; b = p; break;
                case 2: r = p; g = v; b = t; break;
                case 3: r = p; g = q; b = v; break;
                case 4: r = t; g = p; b = v; break;
                case 5: r = v; g = p; b = q; break;
            }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        function interpolateColor(c1, c2, ratio) {
            return c1 + ratio * (c2 - c1);
        }

        function getPaletteColor(palette, position) {
            if (position < 0 || position > 1) position = position - Math.floor(position);

            let stopIndex = 1;
            while (stopIndex < palette.stops.length - 1 && position > palette.stops[stopIndex].pos) {
                stopIndex++;
            }

            const startStop = palette.stops[stopIndex - 1];
            const endStop = palette.stops[stopIndex];
            const ratio = (position - startStop.pos) / (endStop.pos - startStop.pos);
            
            const c1 = startStop.color;
            const c2 = endStop.color;
            
            const comp1 = interpolateColor(c1[0], c2[0], ratio);
            const comp2 = interpolateColor(c1[1], c2[1], ratio);
            const comp3 = interpolateColor(c1[2], c2[2], ratio);
            
            if (palette.colorType === 'HSB') {
                return hsbToRgb(comp1, comp2, comp3);
            }
            return [
                Math.round(Math.max(0, Math.min(255, comp1 * 255))),
                Math.round(Math.max(0, Math.min(255, comp2 * 255))),
                Math.round(Math.max(0, Math.min(255, comp3 * 255)))
            ];
        }

        function createPaletteColors(palette, length, offset) {
            const colors = new Array(length).fill([0, 0, 0]);
            if (length === 0) return colors;

            for (let i = 0; i < length; i++) {
                const position = i / (length > 1 ? length - 1 : 1);
                const colorIndex = (Math.round(i + offset * length)) % length;
                colors[colorIndex] = getPaletteColor(palette, position);
            }
            return colors;
        }

        const standardPalettes = {
            'Spectrum': { colorType: 'HSB', stops: [{ pos: 0, color: [0, 1, 1] }, { pos: 1, color: [1, 1, 1] }] },
            'Grayscale': { colorType: 'RGB', stops: [{ pos: 0, color: [0,0,0] }, { pos: 1, color: [1,1,1] }] },
            'CyclicGrayscale': { colorType: 'RGB', stops: [{ pos: 0, color: [0, 0, 0] }, { pos: 0.5, color: [1, 1, 1] }, { pos: 1, color: [0, 0, 0] }] },
            'Red/Cyan': { colorType: 'RGB', stops: [{ pos: 0, color: [1, 0, 0] }, { pos: 0.5, color: [0, 1, 1] }, { pos: 1, color: [1, 0, 0] }] },
            'Blue/Gold': { colorType: 'RGB', stops: [{ pos: 0, color: [0.1, 0.1, 1] }, { pos: 0.5, color: [1, 0.6, 0] }, { pos: 1, color: [0.3, 0.3, 1] }] },
            'EarthAndSky': { colorType: 'RGB', stops: [{ pos: 0, color: [1,1,1] },{ pos: 0.15, color: [1,0.8,0] },{ pos: 0.33, color: [0.53,0.12,0.075] },{ pos: 0.67, color: [0,0,0.6] },{ pos: 0.85, color: [0,0.4,1] },{ pos: 1, color: [1,1,1] }] },
            'HotAndCold': { colorType: "RGB", stops: [{ pos: 0, color: [1,1,1] },{ pos: 0.16, color: [0,0.4,1] },{ pos: 0.5, color: [0.2,0.2,0.2] },{ pos: 0.84, color: [1,0,0.8] },{ pos: 1, color: [1,1,1] }] },
            'Fire': { colorType: 'RGB', stops: [{ pos: 0, color: [0,0,0] },{ pos: 0.17, color: [1,0,0] },{ pos: 0.83, color: [1,1,0] },{ pos: 1, color: [1,1,1] }] },
            'Cyclic Fire': { colorType: 'RGB', stops: [{ pos: 0, color: [0,0,0] },{ pos: 0.2, color: [1,0,0] },{ pos: 0.4, color: [1,1,0] },{ pos: 0.5, color: [1,1,1] },{ pos: 0.6, color: [1,1,0] },{ pos: 0.8, color: [1,0,0] },{ pos: 1, color: [0,0,0] }] },
            'TreeColors': { colorType: "HSB", stops: [{ pos: 0, color: [0.1266,0.5955,0.2993] },{ pos: 0.33, color: [0.0896,0.3566,0.6575] },{ pos: 0.66, color: [0.6195,0.8215,0.4039] },{ pos: 1, color: [0.1266,0.5955,0.2993] }] },
            'Seashore': { colorType: 'RGB', stops: [{pos: 0, color: [0.7909,0.9961,0.7630]},{pos: 0.1667, color: [0.8974,0.8953,0.6565]},{pos: 0.3333, color: [0.9465,0.3161,0.1267]},{pos: 0.5, color: [0.5184,0.1109,0.0917]},{pos: 0.6667, color: [0.0198,0.4563,0.6839]},{pos: 0.8333, color: [0.5385,0.8259,0.8177]},{pos: 1, color: [0.7909,0.9961,0.7630]}] },
            'Pastels': { colorType: "RGB", stops: [{ pos: 0, color: [0.80585,0.81648,0.82180] },{ pos: 0.180781, color: [0.43882,0.52393,1] },{ pos: 0.418566, color: [1,0.35904,0.58244] },{ pos: 0.627035, color: [1,1,0.52127] },{ pos: 0.858306, color: [0.54787,0.93351,0.56914] },{ pos: 1, color: [0.80585,0.81648,0.82180] }] },
            'Dark': { colorType: "RGB", stops: [{ pos: 0, color: [0.65957,0,0] },{ pos: 0.18241, color: [0,0.30585,0.58776] },{ pos: 0.38599, color: [0.81648,0.41489,0.07180] },{ pos: 0.57166, color: [0,0.48670,0.16489] },{ pos: 0.78338, color: [0.29787,0.13829,0.75] },{ pos: 1, color: [0.65957,0,0] }] },
        };

        const defaultSettings = {
            xmin: '-2.2', xmax: '0.8', ymin: '-1.2', ymax: '1.2',
            width: 800, height: 600,
            maxIterations: 1000,
            palette: standardPalettes.Spectrum,
            paletteLength: 250, paletteOffset: 0,
            interlaced: true, secondPass: false,
        };

        // --- Undoable Reducer Hook (from hooks/useUndoableReducer.ts) ---
        const useUndoableReducer = (reducer, initialPresent) => {
          const initialState = {
            past: [],
            present: initialPresent,
            future: [],
          };

          const [state, dispatch] = useReducer((state, action) => {
            const { past, present, future } = state;
            switch (action.type) {
              case 'UNDO':
                if (past.length === 0) return state;
                const previous = past[past.length - 1];
                return { past: past.slice(0, past.length - 1), present: previous, future: [present, ...future] };
              case 'REDO':
                if (future.length === 0) return state;
                const next = future[0];
                return { past: [...past, present], present: next, future: future.slice(1) };
              case 'SET':
                if (action.newPresent === present) return state;
                return { past: [...past, present], present: action.newPresent, future: [] };
              case 'RESET':
                return { past: [], present: action.newPresent, future: [] };
              default:
                const newPresent = reducer(present, action);
                if (present === newPresent) return state;
                return { past: [...past, present], present: newPresent, future: [] };
            }
          }, initialState);

          const canUndo = state.past.length > 0;
          const canRedo = state.future.length > 0;
          const memoizedDispatch = useCallback(dispatch, [dispatch]);

          return [state, memoizedDispatch, canUndo, canRedo];
        };

        // --- UI Components ---
        const UndoIcon = () => React.createElement("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, React.createElement("path", { d: "M3 7v6h6" }), React.createElement("path", { d: "M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13" }));
        const RedoIcon = () => React.createElement("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, React.createElement("path", { d: "M21 7v6h-6" }), React.createElement("path", { d: "M3 17a9 9 0 0 0 9-9 9 9 0 0 0 6 2.3l3 2.7" }));
        const SettingsIcon = () => React.createElement("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, React.createElement("path", { d: "M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 0 2.4l-.15.08a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.38a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1 0-2.4l.15.08a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z" }), React.createElement("circle", { cx: "12", cy: "12", r: "3" }));
        const SaveIcon = () => React.createElement("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, React.createElement("path", { d: "M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" }), React.createElement("polyline", { points: "17 21 17 13 7 13 7 21" }), React.createElement("polyline", { points: "7 3 7 8 15 8" }));
        const RandomIcon = () => React.createElement("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round"}, React.createElement("path", {d: "M3 7v6h6"}), React.createElement("path", {d: "M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"}), React.createElement("path", {d: "m21 16-4-4 4-4"}), React.createElement("path", {d: "m3 8 4 4-4 4"}));
        
        const Button = ({ onClick, disabled, children, className, title }) => React.createElement("button", { onClick, disabled, title, className: `px-3 py-2 text-sm font-semibold rounded-md flex items-center justify-center gap-2 transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-800 focus:ring-cyan-400 ${disabled ? 'bg-gray-600 text-gray-400 cursor-not-allowed' : 'bg-gray-700 hover:bg-gray-600 text-white'} ${className}` }, children);
        const ControlGroup = ({ title, children }) => React.createElement("details", { open: true, className: "border-b border-gray-700" }, React.createElement("summary", { className: "py-3 px-4 text-sm font-bold uppercase tracking-wider text-gray-400 cursor-pointer hover:bg-gray-800 transition-colors list-none flex items-center justify-between" }, title, React.createElement("svg", { className: "w-4 h-4 text-gray-500 transition-transform duration-200 transform details-arrow", viewBox: "0 0 24 24" }, React.createElement("path", { d: "M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z", fill: "currentColor" }))), React.createElement("div", { className: "p-4 space-y-4" }, children));
        const LabelInput = ({ label, children }) => React.createElement("label", { className: "grid grid-cols-2 items-center gap-2 text-sm" }, React.createElement("span", { className: "text-gray-300" }, label), children);
        const Select = (props) => React.createElement("select", { ...props, className: `w-full bg-gray-800 border border-gray-600 rounded-md px-2 py-1.5 text-sm focus:outline-none focus:ring-1 focus:ring-cyan-400 focus:border-cyan-400 ${props.className}` });
        const Input = (props) => React.createElement("input", { ...props, className: `w-full bg-gray-800 border border-gray-600 rounded-md px-2 py-1.5 text-sm focus:outline-none focus:ring-1 focus:ring-cyan-400 focus:border-cyan-400 ${props.className}` });
        
        // --- Palette Editor Component ---
        const PaletteEditor = ({ palette: initialPalette, onSave, onCancel }) => {
            const [palette, setPalette] = useState(() => JSON.parse(JSON.stringify(initialPalette)));

            const handleStopChange = (index, key, value) => {
                const newStops = [...palette.stops];
                newStops[index] = { ...newStops[index], [key]: value };
                setPalette({ ...palette, stops: newStops });
            };

            const handleAddStop = () => {
                const newStops = [...palette.stops, { pos: 1, color: [1, 1, 1] }]
                    .sort((a, b) => a.pos - b.pos);
                
                let maxGap = 0;
                let insertPos = 0;
                let insertColor = [0,0,0];

                for (let i = 0; i < newStops.length - 1; i++) {
                    const gap = newStops[i+1].pos - newStops[i].pos;
                    if (gap > maxGap) {
                        maxGap = gap;
                        insertPos = newStops[i].pos + gap / 2;
                        insertColor = newStops[i].color.map((c, j) => (c + newStops[i+1].color[j]) / 2);
                    }
                }
                
                newStops.push({ pos: insertPos, color: insertColor });
                setPalette({ ...palette, stops: newStops.sort((a, b) => a.pos - b.pos) });
            };

            const handleRemoveStop = (index) => {
                if (palette.stops.length <= 2) return;
                const newStops = palette.stops.filter((_, i) => i !== index);
                setPalette({ ...palette, stops: newStops });
            };

            const handleSave = () => {
                const sortedPalette = { ...palette, stops: [...palette.stops].sort((a, b) => a.pos - b.pos) };
                onSave(sortedPalette);
            };
            
            const gradient = createPaletteColors(palette, 256, 0)
                .map(c => `rgb(${c[0]},${c[1]},${c[2]})`).join(',');

            return React.createElement("div", { className: "modal-overlay" },
                React.createElement("div", { className: "bg-gray-800 rounded-lg shadow-xl w-full max-w-2xl max-h-[90vh] flex flex-col" },
                    React.createElement("header", { className: "p-4 border-b border-gray-700" }, React.createElement("h2", { className: "text-lg font-bold" }, "Palette Editor")),
                    React.createElement("main", { className: "p-4 flex-1 overflow-y-auto" },
                        React.createElement("div", { className: "h-10 w-full rounded mb-4", style: { background: `linear-gradient(to right, ${gradient})` }}),
                        React.createElement("div", { className: "space-y-3" },
                            palette.stops.map((stop, i) => React.createElement("div", { key: i, className: "grid grid-cols-[auto,1fr,auto,auto] gap-3 items-center" },
                                React.createElement("span", { className: "text-sm font-mono w-12" }, `${(stop.pos * 100).toFixed(1)}%`),
                                React.createElement("input", { type: "range", min: "0", max: "1", step: "0.001", value: stop.pos, onChange: e => handleStopChange(i, 'pos', parseFloat(e.target.value)), disabled: i === 0 || i === palette.stops.length - 1 }),
                                React.createElement("input", { type: "color", value: rgbToHex(stop.color), onChange: e => handleStopChange(i, 'color', hexToRgb(e.target.value)), className: "bg-transparent w-10 h-8 p-0 border-0 cursor-pointer" }),
                                React.createElement("button", { onClick: () => handleRemoveStop(i), disabled: palette.stops.length <= 2, className: "text-red-400 disabled:text-gray-600" }, "Remove")
                            ))
                        )
                    ),
                    React.createElement("footer", { className: "p-4 border-t border-gray-700 flex justify-between" },
                        React.createElement(Button, { onClick: handleAddStop }, "Add Color Stop"),
                        React.createElement("div", { className: "space-x-2" },
                          React.createElement(Button, { onClick: onCancel, className: "bg-gray-600 hover:bg-gray-500" }, "Cancel"),
                          React.createElement(Button, { onClick: handleSave, className: "bg-cyan-600 hover:bg-cyan-500" }, "Save Changes")
                        )
                    )
                )
            );
        };
        
        // --- Mandelbrot Canvas Component (from components/MandelbrotCanvas.tsx) ---
        const DragBox = ({ box }) => {
          if (!box || box.width <= 2 || box.height <= 2) return null;
          return React.createElement("div", {
              className: "absolute border-2 border-dashed border-white pointer-events-none",
              style: { left: box.x, top: box.y, width: box.width, height: box.height }
            });
        };

        const MandelbrotCanvas = forwardRef(({ state, dispatch, setUndoPoint }, ref) => {
          const { settings, workerCount, isComputing } = state;
          const canvasRef = useRef(null);
          const containerRef = useRef(null);
          const offscreenCanvasRef = useRef(null);
          const workersRef = useRef([]);
          const jobIdRef = useRef(0);
          const [dragBox, setDragBox] = useState(null);
          const isDraggingRef = useRef(false);
          const isPanningRef = useRef(false);
          const panStartRef = useRef({ x: 0, y: 0 });
          const [cursor, setCursor] = useState('crosshair');

          useEffect(() => () => workersRef.current.forEach(w => w.terminate()), []);

          const stopComputation = useCallback(() => {
            jobIdRef.current++;
            workersRef.current.forEach(w => w.terminate());
            workersRef.current = [];
            dispatch({ type: 'SET_IS_COMPUTING', payload: false });
            dispatch({ type: 'SET_STATUS', payload: 'Computation stopped by user.' });
            dispatch({ type: 'SET_PROGRESS', payload: 0 });
          }, [dispatch]);

          const zoom = useCallback((zoomFactor) => {
            if (isComputing) return;
            const { xmin, xmax, ymin, ymax } = settings;
            const [xminNum, xmaxNum, yminNum, ymaxNum] = [xmin, xmax, ymin, ymax].map(parseFloat);
            const centerX = xminNum + (xmaxNum - xminNum) / 2;
            const centerY = yminNum + (ymaxNum - yminNum) / 2;
            const newWidth = (xmaxNum - xminNum) * zoomFactor;
            const newHeight = (ymaxNum - yminNum) * zoomFactor;
            const newXmin = centerX - newWidth / 2, newXmax = centerX + newWidth / 2;
            const newYmin = centerY - newHeight / 2, newYmax = centerY + newHeight / 2;
            setUndoPoint(settings);
            dispatch({ type: 'SET_LIMITS', payload: { xmin: newXmin.toPrecision(16), xmax: newXmax.toPrecision(16), ymin: newYmin.toPrecision(16), ymax: newYmax.toPrecision(16) }});
          }, [isComputing, settings, dispatch, setUndoPoint]);

          useImperativeHandle(ref, () => ({ stopComputation, zoom, getCanvas: () => canvasRef.current }), [stopComputation, zoom]);
          
          const startComputation = useCallback(() => {
            if (!canvasRef.current) return;
            jobIdRef.current++;
            const currentJobId = jobIdRef.current;
            dispatch({ type: 'SET_IS_COMPUTING', payload: true });
            dispatch({ type: 'SET_PROGRESS', payload: 0 });
            dispatch({ type: 'SET_STATUS', payload: 'Initializing computation...' });
            workersRef.current.forEach(w => w.terminate());
            const blob = new Blob([getWorkerScript()], { type: 'application/javascript' });
            const workerUrl = URL.createObjectURL(blob);
            workersRef.current = Array.from({ length: workerCount }, () => new Worker(workerUrl));
            if (!offscreenCanvasRef.current || offscreenCanvasRef.current.width !== settings.width || offscreenCanvasRef.current.height !== settings.height) {
                offscreenCanvasRef.current = new OffscreenCanvas(settings.width, settings.height);
            }
            const offscreenCtx = offscreenCanvasRef.current.getContext('2d');
            offscreenCtx.fillStyle = '#111827';
            offscreenCtx.fillRect(0, 0, settings.width, settings.height);
            
            let jobsCompleted = 0;
            const totalJobs = settings.height;
            const palette = createPaletteColors(settings.palette, settings.paletteLength || settings.maxIterations, settings.paletteOffset);

            const drawRow = (row, iterationCounts) => {
                const ctx = offscreenCanvasRef.current?.getContext('2d');
                if (!ctx) return;
                const imageData = ctx.createImageData(settings.width, 1);
                for (let i = 0; i < settings.width; i++) {
                    const iter = iterationCounts[i];
                    const color = iter === -1 ? [0, 0, 0] : palette[iter % palette.length] || [0,0,0];
                    const pxIndex = i * 4;
                    [imageData.data[pxIndex], imageData.data[pxIndex + 1], imageData.data[pxIndex + 2], imageData.data[pxIndex + 3]] = [...color, 255];
                }
                ctx.putImageData(imageData, 0, row);
                const mainCtx = canvasRef.current?.getContext('2d');
                if (mainCtx && offscreenCanvasRef.current) mainCtx.drawImage(offscreenCanvasRef.current, 0, 0);
            };
            
            workersRef.current.forEach(worker => {
              worker.onmessage = (e) => {
                if ('error' in e.data) {
                    dispatch({ type: 'SET_STATUS', payload: e.data.error });
                    dispatch({ type: 'SET_IS_COMPUTING', payload: false });
                    jobIdRef.current++; return;
                }
                const { row, jobId, iterationCounts } = e.data;
                if (jobId !== currentJobId) return;
                drawRow(row, iterationCounts);
                jobsCompleted++;
                const progress = jobsCompleted / totalJobs;
                dispatch({ type: 'SET_PROGRESS', payload: progress });
                dispatch({ type: 'SET_STATUS', payload: `Computing... ${(progress * 100).toFixed(0)}%` });
                if (jobsCompleted >= totalJobs) {
                  dispatch({ type: 'SET_IS_COMPUTING', payload: false });
                  dispatch({ type: 'SET_STATUS', payload: 'Render complete.' });
                  URL.revokeObjectURL(workerUrl);
                }
              };
            });

            const rows = Array.from({ length: settings.height }, (_, i) => i);
            if (settings.interlaced) rows.sort((a, b) => (a % 2) - (b % 2));
            let jobIndex = 0;
            workersRef.current.forEach(worker => {
                if (jobIndex < rows.length) worker.postMessage({ row: rows[jobIndex++], jobId: currentJobId, settings });
                worker.addEventListener('message', function onMessage() {
                    if (jobIndex < rows.length) worker.postMessage({ row: rows[jobIndex++], jobId: currentJobId, settings });
                    else worker.removeEventListener('message', onMessage);
                });
            });
          }, [settings, workerCount, dispatch]);

          useEffect(() => { startComputation(); }, [settings, workerCount, startComputation]);

          const handlePointerDown = (e) => {
            if (isComputing) return;
            const rect = containerRef.current.getBoundingClientRect();
            const x = e.clientX - rect.left, y = e.clientY - rect.top;
            e.preventDefault();
            if (e.pointerType === 'mouse' && e.button === 2) {
              isPanningRef.current = true;
              panStartRef.current = { x: e.clientX, y: e.clientY };
              setCursor('grabbing');
            } else {
              isDraggingRef.current = true;
              setDragBox({ x, y, width: 0, height: 0, startX: x, startY: y });
            }
          };
          
          const handlePointerMove = (e) => {
            if (isPanningRef.current || !isDraggingRef.current || !dragBox) return;
            e.preventDefault();
            const rect = containerRef.current.getBoundingClientRect();
            const currentX = e.clientX - rect.left, currentY = e.clientY - rect.top;
            let width = Math.abs(currentX - dragBox.startX), height = Math.abs(currentY - dragBox.startY);
            const canvasAspect = settings.width / settings.height;
            if (width / height > canvasAspect) height = width / canvasAspect; else width = height * canvasAspect;
            setDragBox({ ...dragBox,
              x: Math.min(dragBox.startX, dragBox.startX + (currentX > dragBox.startX ? 1 : -1) * width),
              y: Math.min(dragBox.startY, dragBox.startY + (currentY > dragBox.startY ? 1 : -1) * height),
              width, height });
          };

          const handlePointerUp = (e) => {
            const { xmin, xmax, ymin, ymax, width, height } = settings;
            const [xminNum, xmaxNum, yminNum, ymaxNum] = [xmin, xmax, ymin, ymax].map(parseFloat);

            if (isPanningRef.current) {
              isPanningRef.current = false; setCursor('crosshair');
              const dxPixels = e.clientX - panStartRef.current.x, dyPixels = e.clientY - panStartRef.current.y;
              const dxComplex = (dxPixels / width) * (xmaxNum - xminNum), dyComplex = (dyPixels / height) * (ymaxNum - yminNum);
              const [newXmin, newXmax] = [xminNum - dxComplex, xmaxNum - dxComplex];
              const [newYmin, newYmax] = [yminNum + dyComplex, ymaxNum + dyComplex];
              setUndoPoint(settings);
              dispatch({ type: 'SET_LIMITS', payload: { xmin: newXmin.toPrecision(16), xmax: newXmax.toPrecision(16), ymin: newYmin.toPrecision(16), ymax: newYmax.toPrecision(16) }});
              return;
            }

            if (!isDraggingRef.current) return;
            isDraggingRef.current = false;
            
            if (!dragBox || dragBox.width <= 5 || dragBox.height <= 5) {
              setDragBox(null);
              const zoomFactor = e.shiftKey ? 2.0 : 0.5;
              const rect = containerRef.current.getBoundingClientRect();
              const clickX = e.clientX - rect.left, clickY = e.clientY - rect.top;
              const mouseX = xminNum + (clickX / width) * (xmaxNum - xminNum);
              const mouseY = ymaxNum - (clickY / height) * (ymaxNum - yminNum);
              const newWidth = (xmaxNum - xminNum) * zoomFactor, newHeight = (ymaxNum - yminNum) * zoomFactor;
              const newXmin = mouseX - (clickX / width) * newWidth, newXmax = newXmin + newWidth;
              const newYmax = mouseY + (clickY / height) * newHeight, newYmin = newYmax - newHeight;
              setUndoPoint(settings);
              dispatch({ type: 'SET_LIMITS', payload: { xmin: newXmin.toPrecision(16), xmax: newXmax.toPrecision(16), ymin: newYmin.toPrecision(16), ymax: newYmax.toPrecision(16) }});
            } else {
              const newXmin = xminNum + (dragBox.x / width) * (xmaxNum - xminNum);
              const newXmax = xminNum + ((dragBox.x + dragBox.width) / width) * (xmaxNum - xminNum);
              const newYmax = ymaxNum - (dragBox.y / height) * (ymaxNum - yminNum);
              const newYmin = ymaxNum - ((dragBox.y + dragBox.height) / height) * (ymaxNum - yminNum);
              setUndoPoint(settings);
              dispatch({ type: 'SET_LIMITS', payload: { xmin: newXmin.toPrecision(16), xmax: newXmax.toPrecision(16), ymin: newYmin.toPrecision(16), ymax: newYmax.toPrecision(16) }});
            }
            setDragBox(null);
          };
          
          return React.createElement("div", {
              ref: containerRef, className: `relative w-full h-full touch-none`,
              style: { cursor: isComputing ? 'wait' : cursor },
              onPointerDown: handlePointerDown, onPointerMove: handlePointerMove,
              onPointerUp: handlePointerUp, onContextMenu: e => e.preventDefault(),
              onPointerLeave: () => { isDraggingRef.current = false; isPanningRef.current = false; setDragBox(null); setCursor('crosshair'); }
            },
            React.createElement("canvas", { ref: canvasRef, width: settings.width, height: settings.height, className: "w-full h-full object-contain" }),
            isComputing && React.createElement("div", { className: "absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center" }, React.createElement("div", { className: "w-24 h-24 border-4 border-dashed rounded-full animate-spin border-cyan-400" })),
            React.createElement(DragBox, { box: dragBox })
          );
        });

        // --- Main App Component (from App.tsx) ---
        const appReducer = (state, action) => {
          switch (action.type) {
            case 'SET_STATE': return { ...state, settings: action.payload };
            case 'SET_LIMITS': return { ...state, settings: { ...state.settings, ...action.payload } };
            case 'SET_IMAGE_SIZE': return { ...state, settings: { ...state.settings, ...action.payload } };
            case 'SET_MAX_ITERATIONS': return { ...state, settings: { ...state.settings, maxIterations: action.payload } };
            case 'SET_PALETTE': return { ...state, settings: { ...state.settings, palette: action.payload } };
            case 'SAVE_PALETTE_AND_CLOSE_EDITOR': return { ...state, settings: { ...state.settings, palette: action.payload }, isEditorOpen: false };
            case 'SET_PALETTE_LENGTH': return { ...state, settings: { ...state.settings, paletteLength: action.payload } };
            case 'SET_PALETTE_OFFSET': return { ...state, settings: { ...state.settings, paletteOffset: action.payload } };
            case 'SET_RENDER_OPTION': return { ...state, settings: { ...state.settings, [action.payload.key]: action.payload.value } };
            case 'SET_WORKER_COUNT': return { ...state, workerCount: action.payload };
            case 'SET_STATUS': return { ...state, status: action.payload };
            case 'SET_PROGRESS': return { ...state, progress: action.payload };
            case 'SET_IS_COMPUTING': return { ...state, isComputing: action.payload };
            case 'TOGGLE_EDITOR': return { ...state, isEditorOpen: !state.isEditorOpen };
            default: return state;
          }
        };

        const imageSizeOptions = {
            '800 600': "800x600 (4:3)", '1024 768': "1024x768 (4:3)",
            '1280 720': "1280x720 (16:9)", '1920 1080': "1920x1080 (16:9)",
            '600 800': "600x800 (Portrait)",
        };

        const App = () => {
            const initialState = {
              settings: defaultSettings,
              workerCount: navigator.hardwareConcurrency || 4,
              status: 'Ready.', progress: 0,
              isComputing: false, isEditorOpen: false,
            };
            const [undoState, dispatchWithUndo, canUndo, canRedo] = useUndoableReducer(appReducer, initialState);
            const canvasRef = useRef(null);
            const [zoomInFactor, setZoomInFactor] = useState(0.5);
            const [zoomOutFactor, setZoomOutFactor] = useState(2.0);
            const state = undoState.present;
            
            const setUndoPoint = useCallback((newSettings) => {
              dispatchWithUndo({ type: 'SET', newPresent: { ...state, settings: newSettings } });
            }, [dispatchWithUndo, state]);

            const handleRestoreDefaults = () => {
                setUndoPoint(state.settings);
                dispatchWithUndo({ type: 'RESET', newPresent: initialState });
            };

            const handleSizeChange = (val) => {
                const [newWidth, newHeight] = val.split(' ').map(Number);
                const { xmin, xmax, ymin, ymax } = state.settings;
                const [xminNum, xmaxNum, yminNum, ymaxNum] = [xmin, xmax, ymin, ymax].map(parseFloat);
                const centerX = (xminNum + xmaxNum) / 2, centerY = (yminNum + ymaxNum) / 2;
                const xRange = xmaxNum - xminNum;
                const newYRange = xRange / (newWidth / newHeight);
                const newYmin = centerY - newYRange / 2, newYmax = centerY + newYRange / 2;
                setUndoPoint(state.settings);
                dispatchWithUndo({ type: 'SET_IMAGE_SIZE', payload: { width: newWidth, height: newHeight, ymin: newYmin.toPrecision(16), ymax: newYmax.toPrecision(16) } });
            };
            
            const handleRandomPalette = () => {
                const c = [Math.random(), Math.random(), Math.random()];
                const stops = [{pos: 0, color: c}];
                for (let i = 1; i <= 5; i++) {
                    stops.push({ pos: i/6, color: [Math.random(), Math.random(), Math.random()] });
                }
                stops.push({ pos: 1, color: c });
                const randomPalette = { colorType: 'RGB', stops };
                setUndoPoint(state.settings);
                dispatchWithUndo({ type: 'SET_PALETTE', payload: randomPalette });
            };

            const handleSaveImage = () => {
                const canvas = canvasRef.current?.getCanvas();
                if (canvas) {
                    const link = document.createElement('a');
                    link.download = 'mandelbrot-explorer.png';
                    link.href = canvas.toDataURL('image/png');
                    link.click();
                }
            };
            
            const currentPaletteName = Object.keys(standardPalettes).find(key => JSON.stringify(standardPalettes[key]) === JSON.stringify(state.settings.palette)) || 'Custom';

            return React.createElement("div", { className: "h-screen w-screen flex flex-col bg-gray-900 overflow-hidden" },
                React.createElement("header", { className: "flex-shrink-0 bg-gray-800 border-b border-gray-700 p-2 flex items-center justify-between z-10" },
                    React.createElement("h1", { className: "text-xl font-bold text-cyan-300" }, "Mandelbrot Explorer"),
                    React.createElement("div", { className: "flex items-center space-x-2" },
                      React.createElement(Button, { onClick: () => dispatchWithUndo({ type: 'UNDO' }), disabled: !canUndo, title: "Undo" }, React.createElement(UndoIcon, null)),
                      React.createElement(Button, { onClick: () => dispatchWithUndo({ type: 'REDO' }), disabled: !canRedo, title: "Redo" }, React.createElement(RedoIcon, null))
                    )
                ),
                React.createElement("main", { className: "flex-1 flex overflow-hidden" },
                    React.createElement("aside", { className: "w-80 flex-shrink-0 bg-gray-800 overflow-y-auto" },
                       React.createElement(ControlGroup, { title: "View" },
                         React.createElement(LabelInput, { label: "Image Size" }, React.createElement(Select, { value: `${state.settings.width} ${state.settings.height}`, onChange: e => handleSizeChange(e.target.value), disabled: state.isComputing }, Object.entries(imageSizeOptions).map(([val, text]) => React.createElement("option", { key: val, value: val }, text)))),
                         React.createElement("div", { className: "grid grid-cols-2 gap-2" },
                            React.createElement(Button, { onClick: handleRestoreDefaults, disabled: state.isComputing }, "Restore Defaults"),
                            React.createElement(Button, { onClick: handleSaveImage, disabled: state.isComputing }, React.createElement(SaveIcon, null), " Save Image")
                         ),
                         React.createElement(Button, { onClick: () => canvasRef.current?.stopComputation(), disabled: !state.isComputing, className: "w-full !bg-red-600 hover:!bg-red-500" }, "Stop")
                       ),
                       React.createElement(ControlGroup, { title: "Navigation" }, React.createElement("div", { className: "text-xs text-gray-400 space-y-2" }, React.createElement("p", null, React.createElement("strong", { className: "text-gray-200" }, "Zoom In/Out:"), " Click/tap on the image. Use Shift+Click to zoom out."), React.createElement("p", null, React.createElement("strong", { className: "text-gray-200" }, "Zoom to Area:"), " Drag a box on the image."), React.createElement("p", null, React.createElement("strong", { className: "text-gray-200" }, "Pan:"), " Drag the image using the right mouse button."))),
                       React.createElement(ControlGroup, { title: "Zoom Controls" },
                         React.createElement(LabelInput, { label: "Zoom In By" }, React.createElement(Select, { value: zoomInFactor, onChange: e => setZoomInFactor(Number(e.target.value)), disabled: state.isComputing }, React.createElement("option", { value: "0.5" }, "2x"), React.createElement("option", { value: "0.2" }, "5x"), React.createElement("option", { value: "0.1" }, "10x"))), React.createElement(Button, { onClick: () => canvasRef.current?.zoom(zoomInFactor), disabled: state.isComputing }, "Zoom In"),
                         React.createElement(LabelInput, { label: "Zoom Out By" }, React.createElement(Select, { value: zoomOutFactor, onChange: e => setZoomOutFactor(Number(e.target.value)), disabled: state.isComputing }, React.createElement("option", { value: "2" }, "2x"), React.createElement("option", { value: "5" }, "5x"), React.createElement("option", { value: "10" }, "10x"))), React.createElement(Button, { onClick: () => canvasRef.current?.zoom(zoomOutFactor), disabled: state.isComputing }, "Zoom Out")
                       ),
                       React.createElement(ControlGroup, { title: "Render" },
                          React.createElement(LabelInput, { label: "Max Iterations" }, React.createElement(Input, { type: "number", value: state.settings.maxIterations, onChange: e => { setUndoPoint(state.settings); dispatchWithUndo({ type: 'SET_MAX_ITERATIONS', payload: parseInt(e.target.value, 10) }) }, disabled: state.isComputing, min: "50", step: "50" })),
                           React.createElement(LabelInput, { label: "Workers" }, React.createElement(Select, { value: state.workerCount, onChange: e => dispatchWithUndo({ type: 'SET_WORKER_COUNT', payload: parseInt(e.target.value, 10) }), disabled: state.isComputing }, [1, 2, 4, 6, 8, 12, 16].filter(c => c <= (navigator.hardwareConcurrency || 16)).map(c => React.createElement("option", { key: c, value: c }, c)))),
                           React.createElement("label", { className: "flex items-center space-x-2 text-sm" }, React.createElement("input", { type: "checkbox", className: "form-checkbox bg-gray-700 border-gray-600 text-cyan-400 focus:ring-cyan-500", checked: state.settings.interlaced, onChange: e => dispatchWithUndo({ type: 'SET_RENDER_OPTION', payload: { key: 'interlaced', value: e.target.checked } }) }), React.createElement("span", null, "Interlaced Draw"))
                       ),
                       React.createElement(ControlGroup, { title: "Palette" },
                          React.createElement(LabelInput, { label: "Palette Length" }, React.createElement(Input, { type: "number", value: state.settings.paletteLength, onChange: e => {setUndoPoint(state.settings); dispatchWithUndo({type: 'SET_PALETTE_LENGTH', payload: parseInt(e.target.value)})}, disabled: state.isComputing, min: "2", step: "10" })),
                           React.createElement(LabelInput, { label: "Palette Offset (%)" }, React.createElement(Input, { type: "range", min: "0", max: "100", value: state.settings.paletteOffset * 100, onChange: e => dispatchWithUndo({ type: 'SET_PALETTE_OFFSET', payload: parseInt(e.target.value) / 100 }) })),
                          React.createElement(LabelInput, { label: "Standard Palette" }, React.createElement(Select, { value: currentPaletteName, onChange: e => {setUndoPoint(state.settings); dispatchWithUndo({type: 'SET_PALETTE', payload: standardPalettes[e.target.value]})}}, Object.keys(standardPalettes).map(name => React.createElement("option", { key: name, value: name }, name)), currentPaletteName === 'Custom' && React.createElement("option", { key: "Custom", value: "Custom", disabled: true }, "Custom"))),
                          React.createElement("div", { className: "grid grid-cols-2 gap-2" },
                            React.createElement(Button, { onClick: handleRandomPalette, disabled: state.isComputing }, React.createElement(RandomIcon, null), " Randomize"),
                            React.createElement(Button, { onClick: () => dispatchWithUndo({ type: 'TOGGLE_EDITOR' }) }, React.createElement(SettingsIcon, null), " Edit Palette")
                          )
                       )
                    ),
                    React.createElement("div", { className: "flex-1 flex flex-col bg-gray-900" },
                        React.createElement("div", { className: "flex-1 relative bg-black flex items-center justify-center" }, React.createElement(MandelbrotCanvas, { ref: canvasRef, state: state, dispatch: dispatchWithUndo, setUndoPoint: setUndoPoint })),
                        React.createElement("footer", { className: "flex-shrink-0 bg-gray-800 border-t border-gray-700 px-4 py-1.5 flex items-center justify-between text-xs" },
                            React.createElement("div", { className: "text-gray-400" }, state.status),
                            React.createElement("div", { className: "w-48 bg-gray-700 rounded-full h-2.5" }, React.createElement("div", { className: "bg-cyan-400 h-2.5 rounded-full", style: { width: `${state.progress * 100}%`, transition: state.progress > 0.01 ? 'width 0.1s' : 'none' }}))
                        )
                    )
                ),
                state.isEditorOpen && React.createElement(PaletteEditor, {
                    palette: state.settings.palette,
                    onSave: (newPalette) => {
                        setUndoPoint(state.settings);
                        dispatchWithUndo({ type: 'SAVE_PALETTE_AND_CLOSE_EDITOR', payload: newPalette });
                    },
                    onCancel: () => dispatchWithUndo({ type: 'TOGGLE_EDITOR' })
                })
            );
        };

        // --- Mount Application ---
        const rootElement = document.getElementById('root');
        if (!rootElement) throw new Error("Could not find root element");
        const root = ReactDOM.createRoot(rootElement);
        root.render(React.createElement(React.StrictMode, null, React.createElement(App, null)));
    </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>
