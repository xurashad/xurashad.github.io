<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Astro-Celestial 2048</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Orbitron', sans-serif;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        .tile {
            transition: transform 0.15s ease-in-out, box-shadow 0.2s ease-in-out, background-color 0.2s ease-in-out;
        }

        @keyframes spawn {
            0% { transform: scale(0.5); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        @keyframes merge {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        .spawn-animation {
            animation: spawn 0.2s ease-out;
        }

        .merge-animation {
            animation: merge 0.2s ease-out;
        }
        
        .game-board {
            touch-action: none;
        }
    </style>
</head>
<body class="bg-slate-900 bg-gradient-to-br from-[#1e0a4e] via-[#0d0d30] to-[#2d0b46] min-h-screen flex items-center justify-center text-white p-4">

    <div class="w-full max-w-md mx-auto">
        <header class="flex justify-between items-center mb-4">
            <div>
                <h1 class="text-5xl font-bold tracking-widest text-transparent bg-clip-text bg-gradient-to-r from-purple-400 via-pink-400 to-indigo-400">2048</h1>
                <p class="text-indigo-300">Join tiles to reach for the stars!</p>
            </div>
            <div class="flex flex-col items-center space-y-2">
                 <div class="bg-slate-800/50 rounded-lg p-3 text-center shadow-lg">
                    <span class="text-sm font-medium text-indigo-300">SCORE</span>
                    <div id="score" class="text-2xl font-bold">0</div>
                </div>
                <button id="reset-button" class="px-4 py-2 bg-purple-600 hover:bg-purple-700 rounded-lg font-bold transition-all duration-200 shadow-md hover:shadow-purple-500/50">
                    New Game
                </button>
            </div>
        </header>

        <main>
            <div id="game-board" class="grid grid-cols-4 gap-3 bg-slate-800/50 rounded-xl p-3 shadow-2xl relative aspect-square">
                <!-- Game tiles will be dynamically inserted here -->
            </div>
        </main>
        
        <!-- Game Over Modal -->
        <div id="game-over-modal" class="hidden fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center z-50">
            <div class="bg-gradient-to-br from-[#2d0b46] to-[#1e0a4e] p-8 rounded-2xl shadow-2xl text-center border border-purple-500/50">
                <h2 class="text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-red-400 to-orange-400 mb-4">Game Over!</h2>
                <p class="text-indigo-200 mb-6">You couldn't reach the cosmos this time.</p>
                <p class="text-indigo-300 mb-2">Final Score: <span id="final-score" class="font-bold text-white text-xl">0</span></p>
                <button id="restart-button-modal" class="mt-4 px-6 py-3 bg-purple-600 hover:bg-purple-700 rounded-lg font-bold transition-all duration-200 shadow-md hover:shadow-purple-500/50">
                    Try Again
                </button>
            </div>
        </div>

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const boardElement = document.getElementById('game-board');
            const scoreElement = document.getElementById('score');
            const resetButton = document.getElementById('reset-button');
            const gameOverModal = document.getElementById('game-over-modal');
            const finalScoreElement = document.getElementById('final-score');
            const restartButtonModal = document.getElementById('restart-button-modal');
            
            const gridSize = 4;
            let board = [];
            let score = 0;
            let isGameOver = false;

            const tileColors = {
                2: 'bg-[#6e44ff] text-white',
                4: 'bg-[#8c5dff] text-white',
                8: 'bg-[#a37aff] text-white',
                16: 'bg-[#b994ff] text-white',
                32: 'bg-[#d0b0ff] text-slate-800',
                64: 'bg-[#e7ccff] text-slate-800',
                128: 'bg-[#ff94c2] text-slate-800',
                256: 'bg-[#ff7ab4] text-white',
                512: 'bg-[#ff61a6] text-white',
                1024: 'bg-[#ff4798] text-white',
                2048: 'bg-[#ff2e8a] text-white',
                4096: 'bg-[#e5006e] text-white',
                8192: 'bg-[#c3005f] text-white'
            };

            function getTileColor(value) {
                return tileColors[value] || 'bg-slate-500 text-white';
            }
            
            function getFontSize(value) {
                if (value >= 10000) return 'text-xl';
                if (value >= 1000) return 'text-2xl';
                if (value >= 100) return 'text-3xl';
                return 'text-4xl';
            }

            function initializeGame() {
                board = Array.from({ length: gridSize }, () => Array(gridSize).fill(0));
                score = 0;
                isGameOver = false;
                gameOverModal.classList.add('hidden');
                addRandomTile(2);
                addRandomTile(2);
                updateBoard();
                updateScore();
            }

            function updateBoard() {
                boardElement.innerHTML = '';
                for (let r = 0; r < gridSize; r++) {
                    for (let c = 0; c < gridSize; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'w-full h-full rounded-lg bg-slate-700/50 flex items-center justify-center';
                        
                        if (board[r][c] !== 0) {
                            const value = board[r][c];
                            const tile = document.createElement('div');
                            tile.className = `tile absolute w-[calc(25%-0.9375rem)] h-[calc(25%-0.9375rem)] rounded-lg flex items-center justify-center font-bold shadow-lg ${getTileColor(value)} ${getFontSize(value)}`;
                            tile.textContent = value;
                            tile.style.top = `calc(0.75rem + ${r} * (25% - 0.1875rem))`;
                            tile.style.left = `calc(0.75rem + ${c} * (25% - 0.1875rem))`;
                            
                            // Apply spawn or merge animations
                            if (tile.dataset.merged === 'true') {
                                tile.classList.add('merge-animation');
                            } else if(tile.dataset.new === 'true') {
                                tile.classList.add('spawn-animation');
                            }
                            
                            boardElement.appendChild(tile);
                        }
                        boardElement.appendChild(cell);
                    }
                }
            }

            function renderBoard(newBoard, animations = []) {
                boardElement.innerHTML = '';
                // Create background cells
                for (let i = 0; i < gridSize * gridSize; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'w-full h-full rounded-lg bg-slate-700/50';
                    boardElement.appendChild(cell);
                }

                for (let r = 0; r < gridSize; r++) {
                    for (let c = 0; c < gridSize; c++) {
                        const value = newBoard[r][c];
                        if (value !== 0) {
                            const tile = document.createElement('div');
                            const animation = animations.find(a => a.to.r === r && a.to.c === c && a.value === value);
                            const wasNew = animations.find(a => a.isNew && a.to.r === r && a.to.c === c);
                            const wasMerged = animations.find(a => a.isMerged && a.to.r === r && a.to.c === c);

                            tile.className = `tile absolute w-[calc(25%-0.9375rem)] h-[calc(25%-0.9375rem)] rounded-lg flex items-center justify-center font-bold shadow-lg ${getTileColor(value)} ${getFontSize(value)}`;
                            tile.textContent = value;
                            
                            if (animation && animation.from) {
                                tile.style.top = `calc(0.75rem + ${animation.from.r} * (25% - 0.1875rem))`;
                                tile.style.left = `calc(0.75rem + ${animation.from.c} * (25% - 0.1875rem))`;
                                // Force reflow to apply initial position before transition
                                tile.offsetWidth;
                            } else {
                                tile.style.top = `calc(0.75rem + ${r} * (25% - 0.1875rem))`;
                                tile.style.left = `calc(0.75rem + ${c} * (25% - 0.1875rem))`;
                            }
                            
                            if (wasNew) {
                                tile.classList.add('spawn-animation');
                            }
                            if (wasMerged) {
                                tile.classList.add('merge-animation');
                            }

                            boardElement.appendChild(tile);
                            
                            // Set target position for transition
                            setTimeout(() => {
                                tile.style.top = `calc(0.75rem + ${r} * (25% - 0.1875rem))`;
                                tile.style.left = `calc(0.75rem + ${c} * (25% - 0.1875rem))`;
                            }, 0);
                        }
                    }
                }
                board = newBoard.map(row => [...row]);
            }


            function getEmptyCells() {
                const emptyCells = [];
                for (let r = 0; r < gridSize; r++) {
                    for (let c = 0; c < gridSize; c++) {
                        if (board[r][c] === 0) {
                            emptyCells.push({ r, c });
                        }
                    }
                }
                return emptyCells;
            }

            function addRandomTile(value = null) {
                const emptyCells = getEmptyCells();
                if (emptyCells.length > 0) {
                    const cell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                    const newValue = value !== null ? value : (Math.random() < 0.9 ? 2 : 4);
                    board[cell.r][cell.c] = newValue;
                    return {r: cell.r, c: cell.c, value: newValue, isNew: true};
                }
                return null;
            }

            function updateScore() {
                scoreElement.textContent = score;
            }

            function move(direction) {
                if (isGameOver) return;

                let moved = false;
                let newBoard = board.map(row => [...row]);
                let tempScore = 0;
                let animations = [];

                function slide(row) {
                    const filteredRow = row.filter(val => val !== 0);
                    const newRow = [];
                    for (let i = 0; i < filteredRow.length; i++) {
                        if (i + 1 < filteredRow.length && filteredRow[i] === filteredRow[i + 1]) {
                            const mergedValue = filteredRow[i] * 2;
                            newRow.push(mergedValue);
                            tempScore += mergedValue;
                            i++;
                        } else {
                            newRow.push(filteredRow[i]);
                        }
                    }
                    while (newRow.length < gridSize) {
                        newRow.push(0);
                    }
                    return newRow;
                }

                function getAnimations(oldRow, newRow, index, isHorizontal) {
                    let oldIdx = 0;
                    let newIdx = 0;
                    const mergedIndices = new Set();
                    
                    while(newIdx < newRow.length && newRow[newIdx] !== 0) {
                        const val = oldRow[oldIdx];
                        if (val === 0) {
                            oldIdx++;
                            continue;
                        }

                        if (oldIdx + 1 < oldRow.length && val === oldRow[oldIdx + 1] && !oldRow.slice(oldIdx + 2).some(v => v !== 0 && v !== val)) {
                            // Merge
                            const from1 = isHorizontal ? { r: index, c: oldIdx } : { r: oldIdx, c: index };
                            const from2 = isHorizontal ? { r: index, c: oldIdx + 1 } : { r: oldIdx + 1, c: index };
                            const to = isHorizontal ? { r: index, c: newIdx } : { r: newIdx, c: index };
                            animations.push({ from: from1, to: to, value: val });
                            animations.push({ from: from2, to: to, value: val, isMerged: true, finalValue: val * 2 });
                            oldIdx += 2;
                        } else {
                            // Slide
                            const from = isHorizontal ? { r: index, c: oldIdx } : { r: oldIdx, c: index };
                            const to = isHorizontal ? { r: index, c: newIdx } : { r: newIdx, c: index };
                            if(from.r !== to.r || from.c !== to.c) {
                                animations.push({ from, to, value: val });
                            }
                            oldIdx++;
                        }
                        newIdx++;
                    }
                }


                if (direction === 'up' || direction === 'down') {
                    for (let c = 0; c < gridSize; c++) {
                        let col = [];
                        for (let r = 0; r < gridSize; r++) {
                            col.push(newBoard[r][c]);
                        }
                        const originalCol = [...col];
                        if (direction === 'down') col.reverse();
                        const newCol = slide(col);
                        if (direction === 'down') newCol.reverse();
                        
                        for (let r = 0; r < gridSize; r++) {
                            if(newBoard[r][c] !== newCol[r]) moved = true;
                            newBoard[r][c] = newCol[r];
                        }
                    }
                } else { // left or right
                    for (let r = 0; r < gridSize; r++) {
                        let row = [...newBoard[r]];
                        const originalRow = [...row];
                        if (direction === 'right') row.reverse();
                        const newRow = slide(row);
                        if (direction === 'right') newRow.reverse();
                        
                        if(JSON.stringify(originalRow) !== JSON.stringify(newRow)) moved = true;
                        newBoard[r] = newRow;
                    }
                }
                
                if (moved) {
                    board = newBoard.map(row => [...row]);
                    score += tempScore;
                    const newTileInfo = addRandomTile();
                    if(newTileInfo) {
                       animations.push(newTileInfo);
                    }
                    renderBoard(board);
                    updateScore();
                    
                    if (checkGameOver()) {
                        isGameOver = true;
                        setTimeout(() => {
                           finalScoreElement.textContent = score;
                           gameOverModal.classList.remove('hidden');
                        }, 500);
                    }
                }
            }
            
            function canMove() {
                // Check for empty cells
                if (getEmptyCells().length > 0) return true;

                // Check for adjacent same-value cells
                for (let r = 0; r < gridSize; r++) {
                    for (let c = 0; c < gridSize; c++) {
                        const val = board[r][c];
                        // Check right
                        if (c < gridSize - 1 && board[r][c+1] === val) return true;
                        // Check down
                        if (r < gridSize - 1 && board[r+1][c] === val) return true;
                    }
                }
                return false;
            }

            function checkGameOver() {
                return !canMove();
            }


            // Event Listeners
            document.addEventListener('keydown', (e) => {
                switch (e.key) {
                    case 'ArrowUp': move('up'); break;
                    case 'ArrowDown': move('down'); break;
                    case 'ArrowLeft': move('left'); break;
                    case 'ArrowRight': move('right'); break;
                }
            });

            resetButton.addEventListener('click', initializeGame);
            restartButtonModal.addEventListener('click', initializeGame);
            
            // Touch controls
            let touchStartX = 0;
            let touchStartY = 0;
            let touchEndX = 0;
            let touchEndY = 0;

            boardElement.addEventListener('touchstart', (e) => {
                touchStartX = e.changedTouches[0].screenX;
                touchStartY = e.changedTouches[0].screenY;
            }, { passive: true });

            boardElement.addEventListener('touchend', (e) => {
                touchEndX = e.changedTouches[0].screenX;
                touchEndY = e.changedTouches[0].screenY;
                handleSwipe();
            });

            function handleSwipe() {
                const dx = touchEndX - touchStartX;
                const dy = touchEndY - touchStartY;
                const absDx = Math.abs(dx);
                const absDy = Math.abs(dy);

                if (Math.max(absDx, absDy) > 30) { // Deadzone
                    if (absDx > absDy) {
                        // Horizontal swipe
                        move(dx > 0 ? 'right' : 'left');
                    } else {
                        // Vertical swipe
                        move(dy > 0 ? 'down' : 'up');
                    }
                }
            }


            // Start the game
            initializeGame();
        });
    </script>
</body>
</html>


